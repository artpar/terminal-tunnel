<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Terminal Tunnel</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            background: #1a1a2e;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        #app { height: 100%; display: flex; flex-direction: column; }

        /* Connection screen */
        #connect-screen {
            flex: 1; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            padding: 20px;
        }
        .logo { font-size: 48px; margin-bottom: 10px; }
        h1 { color: #e94560; margin-bottom: 20px; font-size: 24px; }
        .status { color: #888; margin-bottom: 20px; font-size: 14px; text-align: center; }
        .error { color: #ff6b6b; }
        .success { color: #4ecdc4; }

        .form-container {
            background: #16213e; padding: 30px; border-radius: 12px;
            width: 100%; max-width: 400px;
        }
        .form-container label { color: #888; display: block; margin-bottom: 8px; font-size: 14px; }
        .form-container input, .form-container textarea {
            width: 100%; padding: 12px; border: none; border-radius: 8px;
            background: #0f3460; color: #fff; font-size: 16px;
            margin-bottom: 15px; font-family: monospace;
        }
        .form-container input.code-input {
            font-size: 24px; text-align: center; letter-spacing: 4px;
            text-transform: uppercase;
        }
        .form-container textarea { height: 100px; resize: vertical; font-size: 12px; }
        .form-container input:focus, .form-container textarea:focus { outline: 2px solid #e94560; }
        .form-container button {
            width: 100%; padding: 14px; border: none; border-radius: 8px;
            background: #e94560; color: #fff; font-size: 16px;
            cursor: pointer; font-weight: 600; margin-top: 10px;
        }
        .form-container button:disabled { background: #444; cursor: not-allowed; }
        .form-container button:hover:not(:disabled) { background: #ff6b6b; }
        .form-container button.secondary {
            background: #0f3460; margin-top: 10px;
        }
        .form-container button.secondary:hover { background: #1a4a8a; }

        /* Mode toggle */
        .mode-toggle {
            text-align: center; margin-top: 15px;
        }
        .mode-toggle a {
            color: #888; font-size: 12px; cursor: pointer;
            text-decoration: underline;
        }
        .mode-toggle a:hover { color: #e94560; }

        /* Answer display */
        .answer-display {
            background: #0f3460; padding: 15px; border-radius: 8px;
            margin-top: 15px;
        }
        .answer-display label { color: #4ecdc4; margin-bottom: 10px; }
        .answer-display textarea {
            margin-bottom: 10px; background: #16213e;
        }

        /* Terminal screen */
        #terminal-screen { display: none; flex: 1; flex-direction: column; }
        #terminal-container { flex: 1; padding: 4px; }
        #terminal-container .xterm { height: 100%; }

        .toolbar {
            background: #16213e; padding: 8px 12px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .toolbar-left { color: #4ecdc4; font-size: 14px; }
        .toolbar-right button {
            background: #0f3460; border: none; color: #888;
            padding: 6px 12px; border-radius: 4px; cursor: pointer;
            margin-left: 8px;
        }
        .toolbar-right button:hover { background: #e94560; color: #fff; }

        /* Loading spinner */
        .spinner {
            border: 3px solid #16213e; border-top: 3px solid #e94560;
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="app">
        <!-- Connection Screen -->
        <div id="connect-screen">
            <div class="logo">üîó</div>
            <h1>Terminal Tunnel</h1>
            <div id="status" class="status">Initializing...</div>

            <!-- Short code form (default) -->
            <div id="code-form" class="form-container hidden">
                <label for="code-input">Enter Session Code</label>
                <input type="text" id="code-input" class="code-input" placeholder="ABC123" maxlength="8" autocomplete="off">
                <label for="code-password">Password</label>
                <input type="password" id="code-password" placeholder="Session password" autocomplete="off">
                <button id="code-connect-btn">Connect</button>
                <div class="mode-toggle">
                    <a id="show-manual-mode">Have a connection code instead?</a>
                </div>
            </div>

            <!-- Auto/HTTP mode form -->
            <div id="auto-form" class="form-container hidden">
                <label for="password">Enter Password</label>
                <input type="password" id="password" placeholder="Session password" autocomplete="off">
                <button id="connect-btn">Connect</button>
            </div>

            <!-- Manual mode form -->
            <div id="manual-form" class="form-container hidden">
                <label for="offer-input">Paste Connection Code</label>
                <textarea id="offer-input" placeholder="Paste the full connection code from the host terminal..."></textarea>
                <label for="manual-password">Password</label>
                <input type="password" id="manual-password" placeholder="Session password" autocomplete="off">
                <button id="manual-connect-btn">Connect</button>

                <div id="manual-answer-section" class="hidden">
                    <div class="answer-display">
                        <label>Share this answer code with the host:</label>
                        <textarea id="answer-output" readonly></textarea>
                        <button id="copy-answer-btn" class="secondary">Copy to Clipboard</button>
                    </div>
                    <p style="color: #888; text-align: center; margin-top: 15px; font-size: 12px;">
                        Waiting for host to complete connection...
                    </p>
                </div>

                <div class="mode-toggle">
                    <a id="show-code-mode">Have a 6-digit code?</a>
                </div>
            </div>

            <div id="loading" class="spinner"></div>
        </div>

        <!-- Terminal Screen -->
        <div id="terminal-screen">
            <div class="toolbar">
                <div class="toolbar-left">
                    <span id="connection-status">‚óè Connected</span>
                </div>
                <div class="toolbar-right">
                    <button id="fullscreen-btn">‚õ∂</button>
                    <button id="disconnect-btn">‚úï</button>
                </div>
            </div>
            <div id="terminal-container"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/argon2-browser@1.18.0/dist/argon2-bundled.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <script>
    (function() {
        'use strict';

        // Default relay URL (update when public relay is deployed)
        const DEFAULT_RELAY_URL = 'https://terminal-tunnel-relay.artpar.workers.dev';

        // State
        let pc = null;
        let dc = null;
        let term = null;
        let fitAddon = null;
        let encryptionKey = null;
        let salt = null;
        let connectionMode = 'code'; // code, auto, manual
        let currentCode = null;
        let relayUrl = DEFAULT_RELAY_URL;

        // DOM elements
        const connectScreen = document.getElementById('connect-screen');
        const terminalScreen = document.getElementById('terminal-screen');
        const statusEl = document.getElementById('status');
        const loadingEl = document.getElementById('loading');
        const codeForm = document.getElementById('code-form');
        const autoForm = document.getElementById('auto-form');
        const manualForm = document.getElementById('manual-form');
        const codeInput = document.getElementById('code-input');
        const codePasswordInput = document.getElementById('code-password');
        const codeConnectBtn = document.getElementById('code-connect-btn');
        const passwordInput = document.getElementById('password');
        const connectBtn = document.getElementById('connect-btn');
        const terminalContainer = document.getElementById('terminal-container');
        const connectionStatus = document.getElementById('connection-status');

        // Manual mode elements
        const offerInput = document.getElementById('offer-input');
        const manualPasswordInput = document.getElementById('manual-password');
        const manualConnectBtn = document.getElementById('manual-connect-btn');
        const manualAnswerSection = document.getElementById('manual-answer-section');
        const answerOutput = document.getElementById('answer-output');
        const copyAnswerBtn = document.getElementById('copy-answer-btn');

        // Mode toggle links
        const showManualMode = document.getElementById('show-manual-mode');
        const showCodeMode = document.getElementById('show-code-mode');

        // Message types (must match Go protocol)
        const MSG_DATA = 0x01;
        const MSG_RESIZE = 0x02;
        const MSG_PING = 0x03;
        const MSG_PONG = 0x04;
        const MSG_CLOSE = 0x05;

        // Compact format version
        const COMPACT_VERSION = 0x01;
        const SALT_SIZE = 16;

        // Initialize
        async function init() {
            // Check URL params
            const params = new URLSearchParams(window.location.search);
            const code = params.get('c') || params.get('code');
            const manualMode = params.get('manual');
            const customRelay = params.get('relay');

            if (customRelay) {
                relayUrl = customRelay;
            }

            // If code is provided in URL, auto-fetch session
            if (code) {
                currentCode = code.toUpperCase();
                codeInput.value = currentCode;
                loadingEl.classList.add('hidden');
                codeForm.classList.remove('hidden');
                codePasswordInput.focus();
                setStatus(`Session code: ${currentCode}. Enter password to connect.`, 'info');
                return;
            }

            // Manual mode
            if (manualMode === 'true' || manualMode === '1') {
                connectionMode = 'manual';
                loadingEl.classList.add('hidden');
                manualForm.classList.remove('hidden');
                setStatus('Paste the connection code from the host', 'info');
                return;
            }

            // Default: try to fetch /offer (for direct server mode)
            try {
                setStatus('Checking connection...', 'info');
                const response = await fetch('/offer');
                const data = await response.json();

                salt = base64ToBytes(data.salt || '');
                window.sessionOffer = data.offer;
                window.sessionId = data.sessionId;
                connectionMode = 'auto';

                setStatus('Enter password to connect', 'info');
                loadingEl.classList.add('hidden');
                autoForm.classList.remove('hidden');
                passwordInput.focus();

            } catch (err) {
                // No direct server - show code form
                connectionMode = 'code';
                loadingEl.classList.add('hidden');
                codeForm.classList.remove('hidden');
                codeInput.focus();
                setStatus('Enter session code and password', 'info');
            }
        }

        // Fetch session by short code
        async function fetchSessionByCode(code) {
            const response = await fetch(`${relayUrl}/session/${code.toUpperCase()}`);
            if (!response.ok) {
                if (response.status === 404) {
                    throw new Error('Session not found or expired');
                }
                throw new Error('Failed to fetch session');
            }
            return await response.json();
        }

        // Submit answer to relay
        async function submitAnswerToRelay(code, sdp) {
            const response = await fetch(`${relayUrl}/session/${code.toUpperCase()}/answer`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sdp: sdp })
            });
            if (!response.ok) {
                throw new Error('Failed to submit answer');
            }
        }

        // Connect with short code
        async function connectWithCode() {
            const code = codeInput.value.trim().toUpperCase();
            const password = codePasswordInput.value;

            if (!code || code.length < 4) {
                setStatus('Please enter a valid session code', 'error');
                return;
            }
            if (!password) {
                setStatus('Please enter a password', 'error');
                return;
            }

            codeConnectBtn.disabled = true;
            currentCode = code;
            setStatus('Fetching session...', 'info');

            try {
                const session = await fetchSessionByCode(code);
                salt = base64ToBytes(session.salt || '');

                await doConnect(password, session.sdp, salt, false, code);

            } catch (err) {
                setStatus('Error: ' + err.message, 'error');
                codeConnectBtn.disabled = false;
            }
        }

        // Connect with password (auto/direct mode)
        async function connect() {
            const password = passwordInput.value;
            if (!password) {
                setStatus('Please enter a password', 'error');
                return;
            }

            connectBtn.disabled = true;
            await doConnect(password, window.sessionOffer, salt, false, null);
        }

        // Connect in manual mode
        async function manualConnect() {
            const compactOffer = offerInput.value.trim();
            const password = manualPasswordInput.value;

            if (!compactOffer) {
                setStatus('Please paste the connection code', 'error');
                return;
            }
            if (!password) {
                setStatus('Please enter a password', 'error');
                return;
            }

            manualConnectBtn.disabled = true;
            setStatus('Decoding offer...', 'info');

            try {
                const { sdp, decodedSalt } = decodeCompactOffer(compactOffer);
                salt = decodedSalt;
                window.sessionOffer = sdp;

                await doConnect(password, sdp, salt, true, null);

            } catch (err) {
                setStatus('Failed to decode: ' + err.message, 'error');
                manualConnectBtn.disabled = false;
            }
        }

        // Common connection logic
        async function doConnect(password, offer, saltBytes, isManual, shortCode) {
            try {
                setStatus('Deriving encryption key...', 'info');
                encryptionKey = await deriveKey(password, saltBytes);

                setStatus('Establishing connection...', 'info');

                pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                pc.ondatachannel = (event) => {
                    dc = event.channel;
                    setupDataChannel();
                };

                await pc.setRemoteDescription({ type: 'offer', sdp: offer });
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await waitForICE();

                const answerSDP = pc.localDescription.sdp;

                if (isManual) {
                    // Show answer for user to copy
                    const compactAnswer = encodeCompactAnswer(answerSDP);
                    offerInput.parentElement.classList.add('hidden');
                    manualAnswerSection.classList.remove('hidden');
                    answerOutput.value = compactAnswer;
                    setStatus('Copy the answer code and share with host', 'success');
                } else if (shortCode) {
                    // Submit answer via relay
                    setStatus('Sending answer...', 'info');
                    await submitAnswerToRelay(shortCode, answerSDP);
                    setStatus('Waiting for connection...', 'success');
                } else {
                    // Send answer via HTTP (direct mode)
                    setStatus('Sending answer...', 'info');
                    const resp = await fetch('/answer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ answer: answerSDP })
                    });
                    if (!resp.ok) throw new Error('Failed to send answer');
                    setStatus('Waiting for connection...', 'success');
                }

            } catch (err) {
                setStatus('Connection failed: ' + err.message, 'error');
                codeConnectBtn.disabled = false;
                connectBtn.disabled = false;
                manualConnectBtn.disabled = false;
            }
        }

        // Decode compact offer (matches Go implementation)
        function decodeCompactOffer(encoded) {
            let data;
            try {
                const base64 = encoded.replace(/-/g, '+').replace(/_/g, '/');
                const padded = base64 + '='.repeat((4 - base64.length % 4) % 4);
                data = Uint8Array.from(atob(padded), c => c.charCodeAt(0));
            } catch (e) {
                throw new Error('Invalid base64 encoding');
            }

            if (data.length < 1 + SALT_SIZE + 1) {
                throw new Error('Data too short');
            }

            const version = data[0];
            if (version !== COMPACT_VERSION) {
                throw new Error('Unsupported version: ' + version);
            }

            const decodedSalt = data.slice(1, 1 + SALT_SIZE);
            const compressed = data.slice(1 + SALT_SIZE);

            let sdpBytes;
            try {
                sdpBytes = pako.inflateRaw(compressed);
            } catch (e) {
                throw new Error('Decompression failed: ' + e.message);
            }

            return {
                sdp: new TextDecoder().decode(sdpBytes),
                decodedSalt: decodedSalt
            };
        }

        // Encode compact answer
        function encodeCompactAnswer(sdp) {
            const sdpBytes = new TextEncoder().encode(sdp);
            const compressed = pako.deflateRaw(sdpBytes);

            const data = new Uint8Array(1 + compressed.length);
            data[0] = COMPACT_VERSION;
            data.set(compressed, 1);

            const base64 = btoa(String.fromCharCode.apply(null, data));
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        // Setup data channel handlers
        function setupDataChannel() {
            dc.binaryType = 'arraybuffer';

            dc.onopen = () => {
                console.log('Data channel open');
                showTerminal();
            };

            dc.onclose = () => {
                console.log('Data channel closed');
                connectionStatus.textContent = '‚óè Disconnected';
                connectionStatus.style.color = '#ff6b6b';
            };

            dc.onmessage = async (event) => {
                try {
                    const decrypted = await decrypt(new Uint8Array(event.data));
                    const msg = parseMessage(decrypted);

                    if (msg.type === MSG_DATA) {
                        term.write(new Uint8Array(msg.payload));
                    } else if (msg.type === MSG_PING) {
                        sendMessage(MSG_PONG, new Uint8Array(0));
                    } else if (msg.type === MSG_CLOSE) {
                        dc.close();
                    }
                } catch (err) {
                    console.error('Decrypt error:', err);
                }
            };
        }

        // Show terminal
        function showTerminal() {
            connectScreen.style.display = 'none';
            terminalScreen.style.display = 'flex';

            term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#1a1a2e',
                    foreground: '#e0e0e0',
                    cursor: '#e94560'
                }
            });

            fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(terminalContainer);
            fitAddon.fit();

            term.onData((data) => {
                console.log('Terminal input:', data, 'DC state:', dc ? dc.readyState : 'no dc');
                sendMessage(MSG_DATA, new TextEncoder().encode(data));
            });

            // Click to focus
            terminalContainer.addEventListener('click', () => term.focus());

            term.onResize(({ rows, cols }) => {
                const payload = new Uint8Array(4);
                new DataView(payload.buffer).setUint16(0, rows, false);
                new DataView(payload.buffer).setUint16(2, cols, false);
                sendMessage(MSG_RESIZE, payload);
            });

            window.addEventListener('resize', () => fitAddon.fit());

            // Send initial size
            setTimeout(() => {
                const { rows, cols } = term;
                const payload = new Uint8Array(4);
                new DataView(payload.buffer).setUint16(0, rows, false);
                new DataView(payload.buffer).setUint16(2, cols, false);
                sendMessage(MSG_RESIZE, payload);
            }, 100);

            term.focus();
        }

        // Wait for ICE gathering
        function waitForICE() {
            return new Promise((resolve) => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                    return;
                }
                const check = () => {
                    if (pc.iceGatheringState === 'complete') {
                        pc.removeEventListener('icegatheringstatechange', check);
                        resolve();
                    }
                };
                pc.addEventListener('icegatheringstatechange', check);
                setTimeout(resolve, 3000);
            });
        }

        // Derive encryption key using Argon2
        async function deriveKey(password, saltBytes) {
            const result = await argon2.hash({
                pass: password,
                salt: saltBytes,
                time: 3,
                mem: 65536,
                parallelism: 4,
                hashLen: 32,
                type: argon2.ArgonType.Argon2id
            });
            return new Uint8Array(result.hash);
        }

        // Encrypt data
        async function encrypt(data) {
            const nonce = nacl.randomBytes(24);
            const encrypted = nacl.secretbox(data, nonce, encryptionKey);
            const result = new Uint8Array(nonce.length + encrypted.length);
            result.set(nonce);
            result.set(encrypted, nonce.length);
            return result;
        }

        // Decrypt data
        async function decrypt(data) {
            const nonce = data.slice(0, 24);
            const ciphertext = data.slice(24);
            const decrypted = nacl.secretbox.open(ciphertext, nonce, encryptionKey);
            if (!decrypted) throw new Error('Decryption failed');
            return decrypted;
        }

        // Parse message
        function parseMessage(data) {
            return {
                type: data[0],
                payload: data.slice(1)
            };
        }

        // Send message
        async function sendMessage(type, payload) {
            const msg = new Uint8Array(1 + payload.length);
            msg[0] = type;
            msg.set(payload, 1);
            try {
                const encrypted = await encrypt(msg);
                if (dc && dc.readyState === 'open') {
                    dc.send(encrypted);
                    console.log('Sent message type:', type, 'size:', encrypted.length);
                } else {
                    console.warn('Cannot send - dc:', dc, 'state:', dc ? dc.readyState : 'none');
                }
            } catch (err) {
                console.error('Send error:', err);
            }
        }

        // Set status message
        function setStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = 'status';
            if (type === 'error') statusEl.classList.add('error');
            if (type === 'success') statusEl.classList.add('success');
        }

        // Helper functions
        function base64ToBytes(base64) {
            try {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes;
            } catch (e) {
                return new Uint8Array(0);
            }
        }

        // Event listeners
        codeConnectBtn.addEventListener('click', connectWithCode);
        codeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (codePasswordInput.value) connectWithCode();
                else codePasswordInput.focus();
            }
        });
        codePasswordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') connectWithCode();
        });

        connectBtn.addEventListener('click', connect);
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') connect();
        });

        manualConnectBtn.addEventListener('click', manualConnect);
        manualPasswordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') manualConnect();
        });

        copyAnswerBtn.addEventListener('click', () => {
            answerOutput.select();
            document.execCommand('copy');
            copyAnswerBtn.textContent = 'Copied!';
            setTimeout(() => { copyAnswerBtn.textContent = 'Copy to Clipboard'; }, 2000);
        });

        showManualMode.addEventListener('click', () => {
            codeForm.classList.add('hidden');
            manualForm.classList.remove('hidden');
            connectionMode = 'manual';
        });

        showCodeMode.addEventListener('click', () => {
            manualForm.classList.add('hidden');
            codeForm.classList.remove('hidden');
            connectionMode = 'code';
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        });

        document.getElementById('disconnect-btn').addEventListener('click', () => {
            if (dc) dc.close();
            if (pc) pc.close();
            window.location.reload();
        });

        // Initialize on load
        init();
    })();
    </script>
</body>
</html>
