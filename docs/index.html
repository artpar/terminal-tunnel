<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Security: Content Security Policy to prevent XSS and data exfiltration -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
        style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
        connect-src 'self' https://terminal-tunnel-relay.artpar.workers.dev wss: https:;
        img-src 'self' data:;
        font-src 'self' https://cdn.jsdelivr.net;
        worker-src 'self' blob:;
    ">
    <title>Terminal Tunnel</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            background: #1a1a2e;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        #app { height: 100%; display: flex; flex-direction: column; }

        /* Tab bar */
        .tab-bar {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            background: #0f0f1a;
            border-bottom: 1px solid #2a2a4a;
            padding: 0 8px;
            height: 40px;
            min-height: 40px;
            gap: 4px;
            overflow-x: auto;
            scrollbar-width: none;
        }
        .tab-bar::-webkit-scrollbar { display: none; }
        #tabs-container { display: flex; gap: 4px; flex-wrap: nowrap; }

        .tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: #16213e;
            border: 1px solid #2a2a4a;
            border-radius: 6px 6px 0 0;
            color: #888;
            font-size: 13px;
            cursor: pointer;
            white-space: nowrap;
            max-width: 180px;
            position: relative;
            flex-shrink: 0;
        }
        .tab:hover { background: #1a2a4e; }
        .tab.active {
            background: #1a1a2e;
            color: #fff;
            border-bottom-color: #1a1a2e;
        }
        .tab .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .tab .status-dot.connected { background: #4ecdc4; }
        .tab .status-dot.connecting { background: #f9ca24; animation: pulse 1s infinite; }
        .tab .status-dot.disconnected { background: #ff6b6b; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .tab .tab-name {
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        .tab .close-btn {
            opacity: 0;
            font-size: 16px;
            line-height: 1;
            padding: 2px;
            border-radius: 3px;
        }
        .tab:hover .close-btn { opacity: 0.6; }
        .tab .close-btn:hover { opacity: 1; background: rgba(255,255,255,0.1); }

        .new-tab-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px dashed #444;
            border-radius: 6px;
            color: #666;
            font-size: 18px;
            cursor: pointer;
            flex-shrink: 0;
        }
        .new-tab-btn:hover { background: #16213e; color: #888; border-color: #666; }

        /* Mobile dropdown */
        .mobile-session-select {
            display: none;
            flex: 1;
            padding: 8px 12px;
            background: #16213e;
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        @media (max-width: 600px) {
            .tab { display: none; }
            .mobile-session-select { display: block; }
        }

        /* Main content area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            position: relative;
        }

        /* Session container - each session gets its own container */
        .session-container {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            flex-direction: column;
        }
        .session-container.active {
            display: flex;
        }

        /* Connection screen (for new/reconnect) */
        .connect-screen {
            display: none;
            flex: 1;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .connect-screen.active { display: flex; }

        .logo { font-size: 48px; margin-bottom: 10px; }
        h1 { color: #e94560; margin-bottom: 20px; font-size: 24px; }
        .status { color: #888; margin-bottom: 20px; font-size: 14px; text-align: center; }
        .error { color: #ff6b6b; }
        .success { color: #4ecdc4; }

        .form-container {
            background: #16213e; padding: 30px; border-radius: 12px;
            width: 100%; max-width: 400px;
        }
        .form-container label { color: #888; display: block; margin-bottom: 8px; font-size: 14px; }
        .form-container input, .form-container textarea, .form-container select {
            width: 100%; padding: 12px; border: none; border-radius: 8px;
            background: #0f3460; color: #fff; font-size: 16px;
            margin-bottom: 15px; font-family: monospace;
        }
        .form-container input.code-input {
            font-size: 24px; text-align: center; letter-spacing: 4px;
            text-transform: uppercase;
        }
        .form-container input:focus, .form-container textarea:focus, .form-container select:focus {
            outline: 2px solid #e94560;
        }
        .form-container button {
            width: 100%; padding: 14px; border: none; border-radius: 8px;
            background: #e94560; color: #fff; font-size: 16px;
            cursor: pointer; font-weight: 600; margin-top: 10px;
        }
        .form-container button:disabled { background: #444; cursor: not-allowed; }
        .form-container button:hover:not(:disabled) { background: #ff6b6b; }
        .form-container button.secondary {
            background: #0f3460; margin-top: 10px;
        }
        .form-container button.secondary:hover { background: #1a4a8a; }

        /* Saved sessions list */
        .saved-sessions {
            margin-bottom: 20px;
        }
        .saved-sessions h3 {
            color: #888;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        .saved-session {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: #0f3460;
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
        }
        .saved-session:hover { background: #1a4a8a; }
        .saved-session .session-name { flex: 1; color: #fff; font-size: 14px; }
        .saved-session .session-code { color: #888; font-size: 12px; margin-right: 8px; }
        .saved-session .session-delete {
            opacity: 0;
            color: #ff6b6b;
            font-size: 16px;
            padding: 4px;
        }
        .saved-session:hover .session-delete { opacity: 0.6; }
        .saved-session .session-delete:hover { opacity: 1; }

        /* Terminal container */
        .terminal-screen {
            display: none;
            flex: 1;
            flex-direction: column;
            min-height: 0;
        }
        .terminal-screen.active { display: flex; }

        .terminal-container {
            flex: 1;
            padding: 4px;
            position: relative;
            min-height: 0;
        }
        .terminal-container .xterm { height: 100%; }

        /* Mobile keyboard helper */
        .mobile-input {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0;
            font-size: 16px;
            z-index: 10;
            pointer-events: none;
        }
        .mobile-input.active { pointer-events: auto; }

        /* Status bar */
        .status-bar {
            background: #0f0f1a;
            border-top: 1px solid #2a2a4a;
            padding: 6px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        .status-bar-left {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
        }
        .status-bar-left .latency { color: #4ecdc4; }
        .status-bar-left .latency.warn { color: #f9ca24; }
        .status-bar-left .latency.bad { color: #ff6b6b; }

        .status-bar-right {
            display: flex;
            gap: 8px;
        }
        .status-bar button {
            background: #16213e;
            border: 1px solid #2a2a4a;
            color: #888;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .status-bar button:hover { background: #1a2a4e; color: #fff; }
        .status-bar button.reconnect-btn { border-color: #e94560; color: #e94560; }
        .status-bar button.reconnect-btn:hover { background: #e94560; color: #fff; }

        /* Loading spinner */
        .spinner {
            border: 3px solid #16213e; border-top: 3px solid #e94560;
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Rename input overlay */
        .rename-input {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            padding: 6px 8px;
            background: #16213e;
            border: 2px solid #e94560;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
            z-index: 100;
        }

        .hidden { display: none !important; }

        /* Keyboard shortcut hints */
        .shortcuts-hint {
            position: fixed;
            bottom: 50px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            color: #888;
            display: none;
        }
        .shortcuts-hint.show { display: block; }
        .shortcuts-hint kbd {
            background: #16213e;
            padding: 2px 6px;
            border-radius: 3px;
            color: #fff;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Tab Bar -->
        <div class="tab-bar">
            <div id="tabs-container"></div>
            <select class="mobile-session-select" id="mobile-select"></select>
            <button class="new-tab-btn" id="new-tab-btn" title="New Session (Ctrl+T)">+</button>
        </div>

        <!-- Main Content Area -->
        <div class="main-content" id="main-content">
            <!-- Sessions are dynamically added here -->
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-bar-left">
                <span id="connection-status">No active session</span>
                <span class="latency" id="latency"></span>
            </div>
            <div class="status-bar-right">
                <button id="reconnect-btn" class="reconnect-btn hidden">Reconnect</button>
                <button id="fullscreen-btn" title="Fullscreen">â›¶</button>
            </div>
        </div>
    </div>

    <div class="shortcuts-hint" id="shortcuts-hint">
        <div><kbd>Ctrl+T</kbd> New session</div>
        <div><kbd>Ctrl+W</kbd> Close session</div>
        <div><kbd>Ctrl+1-9</kbd> Switch tabs</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/argon2-browser@1.18.0/dist/argon2-bundled.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <script>
    (function() {
        'use strict';

        const DEFAULT_RELAY_URL = 'https://terminal-tunnel-relay.artpar.workers.dev';
        const STORAGE_KEY = 'tt_sessions';
        const MSG_DATA = 0x01, MSG_RESIZE = 0x02, MSG_PING = 0x03, MSG_PONG = 0x04, MSG_CLOSE = 0x05;
        const COMPACT_VERSION = 0x01, SALT_SIZE = 16;

        // Security: HTML escape function to prevent XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============== Session Class ==============
        class Session {
            constructor(id) {
                this.id = id;
                this.code = null;
                this.name = null;
                this.relayUrl = DEFAULT_RELAY_URL;
                this.connectionMode = 'code';
                this.status = 'new'; // new, connecting, connected, disconnected
                this.pc = null;
                this.dc = null;
                this.term = null;
                this.fitAddon = null;
                this.encryptionKey = null;
                this.salt = null;
                this.container = null;
                this.connectScreen = null;
                this.terminalScreen = null;
                this.latency = null;
                this.lastPingTime = null;
                this.lastPongTime = null;
                this.pingInterval = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.password = null; // Stored for auto-reconnect only
            }

            destroy() {
                if (this.pingInterval) clearInterval(this.pingInterval);
                if (this.dc) this.dc.close();
                if (this.pc) this.pc.close();
                if (this.term) this.term.dispose();
                if (this.container) this.container.remove();
                this.password = null; // Clear password on destroy
            }
        }

        // ============== SessionManager Class ==============
        class SessionManager {
            constructor() {
                this.sessions = new Map();
                this.activeId = null;
                this.savedSessions = this.loadSavedSessions();
            }

            loadSavedSessions() {
                try {
                    return JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
                } catch { return []; }
            }

            saveSessions() {
                const toSave = this.savedSessions.map(s => ({
                    id: s.id, code: s.code, name: s.name,
                    relayUrl: s.relayUrl, lastConnected: s.lastConnected,
                    connectionMode: s.connectionMode
                }));
                localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
            }

            saveSession(session) {
                const existing = this.savedSessions.findIndex(s => s.code === session.code);
                const data = {
                    id: session.id,
                    code: session.code,
                    name: session.name || session.code,
                    relayUrl: session.relayUrl,
                    lastConnected: Date.now(),
                    connectionMode: session.connectionMode
                };
                if (existing >= 0) {
                    this.savedSessions[existing] = { ...this.savedSessions[existing], ...data };
                } else {
                    this.savedSessions.unshift(data);
                    if (this.savedSessions.length > 10) this.savedSessions.pop();
                }
                this.saveSessions();
            }

            deleteSavedSession(code) {
                this.savedSessions = this.savedSessions.filter(s => s.code !== code);
                this.saveSessions();
            }

            createSession() {
                const id = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const session = new Session(id);
                this.sessions.set(id, session);
                return session;
            }

            getSession(id) {
                return this.sessions.get(id);
            }

            getActiveSession() {
                return this.activeId ? this.sessions.get(this.activeId) : null;
            }

            setActive(id) {
                this.activeId = id;
                this.sessions.forEach((s, sid) => {
                    if (s.container) {
                        s.container.classList.toggle('active', sid === id);
                    }
                });
                this.updateUI();
            }

            removeSession(id) {
                const session = this.sessions.get(id);
                if (session) {
                    session.destroy();
                    this.sessions.delete(id);
                }
                if (this.activeId === id) {
                    const remaining = Array.from(this.sessions.keys());
                    this.activeId = remaining.length > 0 ? remaining[0] : null;
                }
                this.updateUI();
            }

            updateUI() {
                renderTabs();
                renderMobileSelect();
                updateStatusBar();
            }
        }

        const manager = new SessionManager();

        // ============== DOM References ==============
        const tabsContainer = document.getElementById('tabs-container');
        const mobileSelect = document.getElementById('mobile-select');
        const mainContent = document.getElementById('main-content');
        const newTabBtn = document.getElementById('new-tab-btn');
        const reconnectBtn = document.getElementById('reconnect-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const connectionStatusEl = document.getElementById('connection-status');
        const latencyEl = document.getElementById('latency');

        // ============== Initialization ==============
        function init() {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('c') || params.get('code');

            if (code) {
                const session = manager.createSession();
                session.code = code.toUpperCase();
                manager.setActive(session.id);
                createSessionUI(session);
                showConnectScreen(session, 'password');
            } else {
                showNewSessionDialog();
            }

            setupEventListeners();
        }

        // ============== UI Rendering ==============
        function renderTabs() {
            tabsContainer.innerHTML = '';
            manager.sessions.forEach((session, id) => {
                const tab = document.createElement('div');
                tab.className = 'tab' + (id === manager.activeId ? ' active' : '');
                tab.dataset.id = id;

                const statusClass = session.status === 'connected' ? 'connected' :
                                   session.status === 'connecting' ? 'connecting' : 'disconnected';

                // Security: Use DOM methods instead of innerHTML to prevent XSS
                const statusDot = document.createElement('span');
                statusDot.className = 'status-dot ' + statusClass;

                const tabName = document.createElement('span');
                tabName.className = 'tab-name';
                tabName.textContent = session.name || session.code || 'New Session'; // Safe: textContent escapes HTML

                const closeBtn = document.createElement('span');
                closeBtn.className = 'close-btn';
                closeBtn.dataset.action = 'close';
                closeBtn.textContent = 'Ã—';

                tab.appendChild(statusDot);
                tab.appendChild(tabName);
                tab.appendChild(closeBtn);

                tab.addEventListener('click', (e) => {
                    if (e.target.dataset.action === 'close') {
                        if (manager.sessions.size > 1 || session.status !== 'connected') {
                            manager.removeSession(id);
                            if (manager.sessions.size === 0) showNewSessionDialog();
                        }
                    } else {
                        manager.setActive(id);
                    }
                });

                tab.addEventListener('dblclick', (e) => {
                    if (e.target.classList.contains('tab-name')) {
                        startRename(session, e.target);
                    }
                });

                tabsContainer.appendChild(tab);
            });
        }

        function renderMobileSelect() {
            mobileSelect.innerHTML = '';
            manager.sessions.forEach((session, id) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = session.name || session.code || 'New Session';
                option.selected = id === manager.activeId;
                mobileSelect.appendChild(option);
            });
        }

        function startRename(session, element) {
            const rect = element.getBoundingClientRect();
            const input = document.createElement('input');
            input.className = 'rename-input';
            input.value = session.name || session.code || '';
            input.style.top = rect.top + 'px';
            input.style.left = rect.left + 'px';
            input.style.width = rect.width + 'px';

            document.body.appendChild(input);
            input.focus();
            input.select();

            const finish = () => {
                const newName = input.value.trim();
                if (newName) {
                    session.name = newName;
                    manager.saveSession(session);
                }
                input.remove();
                renderTabs();
            };

            input.addEventListener('blur', finish);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') finish();
                if (e.key === 'Escape') input.remove();
            });
        }

        function updateStatusBar() {
            const session = manager.getActiveSession();
            if (!session) {
                connectionStatusEl.textContent = 'No active session';
                latencyEl.textContent = '';
                reconnectBtn.classList.add('hidden');
                return;
            }

            const statusText = {
                'new': 'Ready to connect',
                'connecting': 'Connecting...',
                'connected': 'â— Connected',
                'disconnected': 'â—‹ Disconnected'
            };

            connectionStatusEl.textContent = statusText[session.status] || session.status;
            connectionStatusEl.style.color = session.status === 'connected' ? '#4ecdc4' :
                                             session.status === 'connecting' ? '#f9ca24' : '#ff6b6b';

            if (session.latency !== null && session.status === 'connected') {
                latencyEl.textContent = `${session.latency}ms`;
                latencyEl.className = 'latency' + (session.latency > 500 ? ' bad' : session.latency > 100 ? ' warn' : '');
            } else {
                latencyEl.textContent = '';
            }

            reconnectBtn.classList.toggle('hidden', session.status !== 'disconnected' || !session.code);
        }

        // ============== Session UI Creation ==============
        function createSessionUI(session) {
            const container = document.createElement('div');
            container.className = 'session-container';
            container.id = 'session-' + session.id;

            container.innerHTML = `
                <div class="connect-screen">
                    <div class="logo">ðŸ”—</div>
                    <h1>Terminal Tunnel</h1>
                    <div class="status-text status">Initializing...</div>
                    <div class="form-area"></div>
                    <div class="spinner hidden"></div>
                </div>
                <div class="terminal-screen">
                    <div class="terminal-container">
                        <input type="text" class="mobile-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="text">
                    </div>
                </div>
            `;

            mainContent.appendChild(container);
            session.container = container;
            session.connectScreen = container.querySelector('.connect-screen');
            session.terminalScreen = container.querySelector('.terminal-screen');

            if (session.id === manager.activeId) {
                container.classList.add('active');
            }

            renderTabs();
        }

        function showConnectScreen(session, mode = 'full') {
            session.connectScreen.classList.add('active');
            session.terminalScreen.classList.remove('active');

            const formArea = session.connectScreen.querySelector('.form-area');
            const statusText = session.connectScreen.querySelector('.status-text');

            if (mode === 'password') {
                statusText.textContent = `Session code: ${session.code}. Enter password to connect.`;
                // Security: Use escapeHtml for user-provided data
                formArea.innerHTML = `
                    <div class="form-container">
                        <label>Session Name (optional)</label>
                        <input type="text" class="name-input" placeholder="e.g., Dev Server" value="${escapeHtml(session.name || '')}">
                        <label>Password</label>
                        <input type="password" class="password-input" placeholder="Session password" autocomplete="off">
                        <button class="connect-btn">Connect</button>
                    </div>
                `;
            } else {
                // Security: Use escapeHtml for all user-provided data
                const savedHtml = manager.savedSessions.length > 0 ? `
                    <div class="saved-sessions">
                        <h3>Recent Sessions</h3>
                        ${manager.savedSessions.map(s => `
                            <div class="saved-session" data-code="${escapeHtml(s.code)}" data-name="${escapeHtml(s.name || '')}" data-relay="${escapeHtml(s.relayUrl || DEFAULT_RELAY_URL)}">
                                <span class="session-name">${escapeHtml(s.name || s.code)}</span>
                                <span class="session-code">${escapeHtml(s.code)}</span>
                                <span class="session-delete" data-action="delete">&times;</span>
                            </div>
                        `).join('')}
                    </div>
                ` : '';

                statusText.textContent = 'Enter session code and password';
                formArea.innerHTML = `
                    <div class="form-container">
                        ${savedHtml}
                        <label>Session Code</label>
                        <input type="text" class="code-input" placeholder="ABC12345" maxlength="8" autocomplete="off" value="${escapeHtml(session.code || '')}">
                        <label>Session Name (optional)</label>
                        <input type="text" class="name-input" placeholder="e.g., Dev Server">
                        <label>Password</label>
                        <input type="password" class="password-input" placeholder="Session password" autocomplete="off">
                        <button class="connect-btn">Connect</button>
                    </div>
                `;
            }

            // Event listeners
            const connectBtn = formArea.querySelector('.connect-btn');
            const passwordInput = formArea.querySelector('.password-input');
            const codeInput = formArea.querySelector('.code-input');
            const nameInput = formArea.querySelector('.name-input');

            connectBtn.addEventListener('click', () => startConnection(session, formArea));
            passwordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') startConnection(session, formArea);
            });
            if (codeInput) {
                codeInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') passwordInput.focus();
                });
            }

            // Saved session click handlers
            formArea.querySelectorAll('.saved-session').forEach(el => {
                el.addEventListener('click', (e) => {
                    if (e.target.dataset.action === 'delete') {
                        manager.deleteSavedSession(el.dataset.code);
                        el.remove();
                        return;
                    }
                    if (codeInput) codeInput.value = el.dataset.code;
                    if (nameInput) nameInput.value = el.dataset.name;
                    session.relayUrl = el.dataset.relay;
                    passwordInput.focus();
                });
            });

            setTimeout(() => (codeInput || passwordInput).focus(), 100);
        }

        function showNewSessionDialog() {
            const session = manager.createSession();
            manager.setActive(session.id);
            createSessionUI(session);
            showConnectScreen(session, 'full');
        }

        // ============== Connection Logic ==============
        async function startConnection(session, formArea) {
            const codeInput = formArea.querySelector('.code-input');
            const passwordInput = formArea.querySelector('.password-input');
            const nameInput = formArea.querySelector('.name-input');
            const connectBtn = formArea.querySelector('.connect-btn');
            const spinner = session.connectScreen.querySelector('.spinner');
            const statusText = session.connectScreen.querySelector('.status-text');

            const code = (codeInput ? codeInput.value : session.code || '').trim().toUpperCase();
            const password = passwordInput.value;
            const name = nameInput ? nameInput.value.trim() : '';

            if (!code || code.length < 4) {
                statusText.textContent = 'Please enter a valid session code';
                statusText.classList.add('error');
                return;
            }
            if (!password) {
                statusText.textContent = 'Please enter a password';
                statusText.classList.add('error');
                return;
            }

            session.code = code;
            session.name = name || code;
            session.password = password; // Store for auto-reconnect
            session.status = 'connecting';
            connectBtn.disabled = true;
            spinner.classList.remove('hidden');
            statusText.classList.remove('error');
            manager.updateUI();

            try {
                statusText.textContent = 'Fetching session...';
                const response = await fetch(`${session.relayUrl}/session/${code}`);
                if (!response.ok) {
                    throw new Error(response.status === 404 ? 'Session not found or expired' : 'Failed to fetch session');
                }
                const data = await response.json();
                session.salt = base64ToBytes(data.salt || '');

                statusText.textContent = 'Deriving encryption key...';
                session.encryptionKey = await deriveKey(password, session.salt);

                statusText.textContent = 'Establishing connection...';
                await establishConnection(session, data.sdp, code);

            } catch (err) {
                statusText.textContent = 'Error: ' + err.message;
                statusText.classList.add('error');
                session.status = 'disconnected';
                connectBtn.disabled = false;
                spinner.classList.add('hidden');
                manager.updateUI();
            }
        }

        async function establishConnection(session, offerSdp, code) {
            const statusText = session.connectScreen.querySelector('.status-text');

            session.pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });

            session.pc.ondatachannel = (event) => {
                session.dc = event.channel;
                setupDataChannel(session);
            };

            session.pc.onconnectionstatechange = () => {
                const state = session.pc.connectionState;
                console.log('Connection state:', state);
                if (state === 'disconnected' || state === 'failed') {
                    handleDisconnect(session, true); // Auto-reconnect on ICE failure
                }
            };

            await session.pc.setRemoteDescription({ type: 'offer', sdp: offerSdp });
            const answer = await session.pc.createAnswer();
            await session.pc.setLocalDescription(answer);
            await waitForICE(session.pc);

            statusText.textContent = 'Sending answer...';
            const resp = await fetch(`${session.relayUrl}/session/${code}/answer`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sdp: session.pc.localDescription.sdp })
            });

            if (!resp.ok) throw new Error('Failed to submit answer');

            statusText.textContent = 'Waiting for connection...';

            setTimeout(() => {
                if (session.status === 'connecting') {
                    statusText.textContent = 'Connection timeout. Host may have disconnected.';
                    statusText.classList.add('error');
                    session.status = 'disconnected';
                    manager.updateUI();
                }
            }, 15000);
        }

        function setupDataChannel(session) {
            session.dc.binaryType = 'arraybuffer';

            session.dc.onopen = () => {
                session.status = 'connected';
                if (session.reconnectAttempts > 0) {
                    console.log('Reconnected successfully after', session.reconnectAttempts, 'attempt(s)');
                    session.reconnectAttempts = 0; // Reset only when truly connected
                }
                manager.saveSession(session);
                showTerminal(session);
                startPingInterval(session);
                manager.updateUI();
            };

            session.dc.onclose = () => handleDisconnect(session, true); // Auto-reconnect on dc close

            session.dc.onmessage = async (event) => {
                try {
                    const decrypted = await decrypt(session, new Uint8Array(event.data));
                    const msg = parseMessage(decrypted);

                    if (msg.type === MSG_DATA) {
                        session.term.write(new Uint8Array(msg.payload));
                    } else if (msg.type === MSG_PING) {
                        sendMessage(session, MSG_PONG, new Uint8Array(0));
                    } else if (msg.type === MSG_PONG) {
                        session.lastPongTime = Date.now();
                        if (session.lastPingTime) {
                            session.latency = Date.now() - session.lastPingTime;
                            manager.updateUI();
                        }
                    } else if (msg.type === MSG_CLOSE) {
                        session.dc.close();
                    }
                } catch (err) { /* ignore decryption errors */ }
            };
        }

        function handleDisconnect(session, autoReconnect = false) {
            if (session.status === 'disconnected') return; // Already disconnected
            session.status = 'disconnected';
            if (session.pingInterval) {
                clearInterval(session.pingInterval);
                session.pingInterval = null;
            }
            manager.updateUI();
            if (autoReconnect) {
                attemptAutoReconnect(session);
            }
        }

        const PONG_TIMEOUT = 15000; // 15 seconds without pong = connection dead
        const RECONNECT_BASE_DELAY = 1000; // Start with 1 second
        const RECONNECT_MAX_DELAY = 30000; // Max 30 seconds

        function startPingInterval(session) {
            session.lastPongTime = Date.now(); // Initialize to now
            session.pingInterval = setInterval(() => {
                // Check for pong timeout FIRST (outside dc state check)
                if (session.lastPongTime && (Date.now() - session.lastPongTime) > PONG_TIMEOUT) {
                    console.log('Connection timed out - no pong received for', Date.now() - session.lastPongTime, 'ms');
                    handleDisconnect(session, true); // Auto-reconnect on timeout
                    return;
                }

                // Only send ping if data channel is open
                if (session.dc && session.dc.readyState === 'open') {
                    session.lastPingTime = Date.now();
                    sendMessage(session, MSG_PING, new Uint8Array(0));
                } else if (session.status === 'connected') {
                    // Data channel not open but we think we're connected - that's a problem
                    console.log('Data channel not open but status is connected, dc state:',
                        session.dc ? session.dc.readyState : 'no dc');
                }
            }, 5000);
        }

        function attemptAutoReconnect(session) {
            if (!session.code || !session.password) return; // Can't reconnect without credentials
            if (session.reconnectAttempts >= session.maxReconnectAttempts) {
                console.log('Max reconnect attempts reached');
                session.reconnectAttempts = 0;
                return;
            }

            session.reconnectAttempts++;
            const delay = Math.min(
                RECONNECT_BASE_DELAY * Math.pow(2, session.reconnectAttempts - 1),
                RECONNECT_MAX_DELAY
            );

            console.log(`Auto-reconnecting in ${delay}ms (attempt ${session.reconnectAttempts}/${session.maxReconnectAttempts})`);

            setTimeout(async () => {
                if (session.status === 'disconnected' && session.code) {
                    session.status = 'connecting';
                    manager.updateUI();

                    // Clean up old connection
                    if (session.dc) { try { session.dc.close(); } catch(e) {} session.dc = null; }
                    if (session.pc) { try { session.pc.close(); } catch(e) {} session.pc = null; }

                    try {
                        // Fetch session from relay
                        const response = await fetch(`${session.relayUrl}/session/${session.code}`);
                        if (!response.ok) {
                            throw new Error(response.status === 404 ? 'Session expired' : 'Failed to fetch session');
                        }
                        const data = await response.json();
                        session.salt = base64ToBytes(data.salt || '');

                        // Re-derive key if salt changed, otherwise reuse
                        if (!session.encryptionKey) {
                            session.encryptionKey = await deriveKey(session.password, session.salt);
                        }

                        // Establish connection (success is handled in dc.onopen)
                        await establishConnection(session, data.sdp, session.code);
                        // Note: reconnectAttempts is reset in dc.onopen when truly connected
                    } catch (err) {
                        console.log('Reconnect failed:', err.message);
                        session.status = 'disconnected';
                        manager.updateUI();
                        attemptAutoReconnect(session); // Try again
                    }
                }
            }, delay);
        }

        // ============== Terminal ==============
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        }

        function showTerminal(session) {
            session.connectScreen.classList.remove('active');
            session.terminalScreen.classList.add('active');

            const termContainer = session.terminalScreen.querySelector('.terminal-container');
            const mobileInput = session.terminalScreen.querySelector('.mobile-input');
            const mobile = isMobile();

            session.term = new Terminal({
                cursorBlink: true,
                fontSize: mobile ? 12 : 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: { background: '#1a1a2e', foreground: '#e0e0e0', cursor: '#e94560' }
            });

            session.fitAddon = new FitAddon.FitAddon();
            session.term.loadAddon(session.fitAddon);
            session.term.open(termContainer);
            session.fitAddon.fit();

            session.term.onData((data) => {
                sendMessage(session, MSG_DATA, new TextEncoder().encode(data));
            });

            if (mobile) {
                mobileInput.classList.add('active');
                mobileInput.addEventListener('input', (e) => {
                    if (e.target.value) {
                        sendMessage(session, MSG_DATA, new TextEncoder().encode(e.target.value));
                        e.target.value = '';
                    }
                });
                mobileInput.addEventListener('keydown', (e) => {
                    let data = null;
                    switch (e.key) {
                        case 'Enter': data = '\r'; break;
                        case 'Backspace': data = '\x7f'; break;
                        case 'Tab': data = '\t'; e.preventDefault(); break;
                        case 'Escape': data = '\x1b'; break;
                        case 'ArrowUp': data = '\x1b[A'; break;
                        case 'ArrowDown': data = '\x1b[B'; break;
                        case 'ArrowRight': data = '\x1b[C'; break;
                        case 'ArrowLeft': data = '\x1b[D'; break;
                    }
                    if (data) {
                        sendMessage(session, MSG_DATA, new TextEncoder().encode(data));
                        e.preventDefault();
                    }
                });
                termContainer.addEventListener('touchstart', () => mobileInput.focus(), { passive: true });
                termContainer.addEventListener('click', () => mobileInput.focus());
            } else {
                termContainer.addEventListener('click', () => session.term.focus());
                session.term.focus();
            }

            session.term.onResize(({ rows, cols }) => {
                const payload = new Uint8Array(4);
                new DataView(payload.buffer).setUint16(0, rows, false);
                new DataView(payload.buffer).setUint16(2, cols, false);
                sendMessage(session, MSG_RESIZE, payload);
            });

            window.addEventListener('resize', () => {
                if (session.fitAddon) session.fitAddon.fit();
            });

            setTimeout(() => {
                session.fitAddon.fit();
                const { rows, cols } = session.term;
                const payload = new Uint8Array(4);
                new DataView(payload.buffer).setUint16(0, rows, false);
                new DataView(payload.buffer).setUint16(2, cols, false);
                sendMessage(session, MSG_RESIZE, payload);
            }, 100);
        }

        // ============== Crypto ==============
        async function deriveKey(password, saltBytes) {
            const result = await argon2.hash({
                pass: password, salt: saltBytes,
                time: 3, mem: 65536, parallelism: 4, hashLen: 32,
                type: argon2.ArgonType.Argon2id
            });
            return new Uint8Array(result.hash);
        }

        async function encrypt(session, data) {
            const nonce = nacl.randomBytes(24);
            const encrypted = nacl.secretbox(data, nonce, session.encryptionKey);
            const result = new Uint8Array(nonce.length + encrypted.length);
            result.set(nonce);
            result.set(encrypted, nonce.length);
            return result;
        }

        async function decrypt(session, data) {
            const nonce = data.slice(0, 24);
            const ciphertext = data.slice(24);
            const decrypted = nacl.secretbox.open(ciphertext, nonce, session.encryptionKey);
            if (!decrypted) throw new Error('Decryption failed');
            return decrypted;
        }

        function parseMessage(data) {
            const type = data[0];
            const length = (data[1] << 8) | data[2];
            return { type, payload: data.slice(3, 3 + length) };
        }

        async function sendMessage(session, type, payload) {
            const msg = new Uint8Array(3 + payload.length);
            msg[0] = type;
            msg[1] = (payload.length >> 8) & 0xff;
            msg[2] = payload.length & 0xff;
            msg.set(payload, 3);
            const encrypted = await encrypt(session, msg);
            if (session.dc && session.dc.readyState === 'open') {
                session.dc.send(encrypted);
            }
        }

        function base64ToBytes(base64) {
            try {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                return bytes;
            } catch { return new Uint8Array(0); }
        }

        function waitForICE(pc) {
            return new Promise((resolve) => {
                if (pc.iceGatheringState === 'complete') { resolve(); return; }
                const check = () => {
                    if (pc.iceGatheringState === 'complete') {
                        pc.removeEventListener('icegatheringstatechange', check);
                        resolve();
                    }
                };
                pc.addEventListener('icegatheringstatechange', check);
                setTimeout(resolve, 3000);
            });
        }

        // ============== Event Listeners ==============
        function setupEventListeners() {
            newTabBtn.addEventListener('click', showNewSessionDialog);

            mobileSelect.addEventListener('change', (e) => {
                manager.setActive(e.target.value);
            });

            reconnectBtn.addEventListener('click', () => {
                const session = manager.getActiveSession();
                if (session && session.code) {
                    session.status = 'new';
                    session.pc = null;
                    session.dc = null;
                    showConnectScreen(session, 'password');
                    manager.updateUI();
                }
            });

            fullscreenBtn.addEventListener('click', () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Don't capture if in input (except terminal)
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.ctrlKey || e.metaKey) {
                    // Ctrl+T: New tab
                    if (e.key === 't') {
                        e.preventDefault();
                        showNewSessionDialog();
                    }
                    // Ctrl+W: Close tab
                    else if (e.key === 'w') {
                        e.preventDefault();
                        const session = manager.getActiveSession();
                        if (session && (manager.sessions.size > 1 || session.status !== 'connected')) {
                            manager.removeSession(session.id);
                            if (manager.sessions.size === 0) showNewSessionDialog();
                        }
                    }
                    // Ctrl+1-9: Switch tabs
                    else if (e.key >= '1' && e.key <= '9') {
                        e.preventDefault();
                        const idx = parseInt(e.key) - 1;
                        const ids = Array.from(manager.sessions.keys());
                        if (ids[idx]) manager.setActive(ids[idx]);
                    }
                    // Ctrl+Shift+R: Reconnect
                    else if (e.key === 'R' && e.shiftKey) {
                        e.preventDefault();
                        reconnectBtn.click();
                    }
                }
            });

            // Show shortcuts hint on ?
            document.addEventListener('keydown', (e) => {
                if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
                    const hint = document.getElementById('shortcuts-hint');
                    hint.classList.toggle('show');
                    setTimeout(() => hint.classList.remove('show'), 3000);
                }
            });
        }

        // ============== Start ==============
        init();
    })();
    </script>
</body>
</html>
