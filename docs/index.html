<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
    <!-- Security: Content Security Policy to prevent XSS and data exfiltration -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
        style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
        connect-src 'self' https://terminal-tunnel-relay.artpar.workers.dev wss: https:;
        img-src 'self' data:;
        font-src 'self' https://cdn.jsdelivr.net;
        worker-src 'self' blob:;
    ">
    <title>Terminal Tunnel</title>
    <!-- PWA Support -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TermTunnel">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect fill='%231a1a2e' width='512' height='512' rx='64'/><text x='256' y='300' text-anchor='middle' font-size='200' font-family='monospace' fill='%234ecdc4'>%3E_</text></svg>">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            height: 100dvh;
            height: 100svh; /* Small viewport height - stable when keyboard shown */
            background: #1a1a2e;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            /* Prevent iOS bounce/overscroll */
            position: fixed;
            width: 100%;
            overscroll-behavior: none;
        }
        #app {
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* This will be set dynamically by JS for keyboard */
        }

        /* Tab bar */
        .tab-bar {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            background: #0f0f1a;
            border-bottom: 1px solid #2a2a4a;
            padding: 0 8px;
            height: 40px;
            min-height: 40px;
            gap: 4px;
            overflow-x: auto;
            scrollbar-width: none;
        }
        .tab-bar::-webkit-scrollbar { display: none; }
        #tabs-container { display: flex; gap: 4px; flex-wrap: nowrap; }

        .tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: #16213e;
            border: 1px solid #2a2a4a;
            border-radius: 6px 6px 0 0;
            color: #888;
            font-size: 13px;
            cursor: pointer;
            white-space: nowrap;
            max-width: 180px;
            position: relative;
            flex-shrink: 0;
        }
        .tab:hover { background: #1a2a4e; }
        .tab.active {
            background: #1a1a2e;
            color: #fff;
            border-bottom-color: #1a1a2e;
        }
        .tab .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .tab .status-dot.connected { background: #4ecdc4; }
        .tab .status-dot.connecting { background: #f9ca24; animation: pulse 1s infinite; }
        .tab .status-dot.disconnected { background: #ff6b6b; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .tab .tab-name {
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        .tab .close-btn {
            opacity: 0;
            font-size: 16px;
            line-height: 1;
            padding: 2px;
            border-radius: 3px;
        }
        .tab:hover .close-btn { opacity: 0.6; }
        .tab .close-btn:hover { opacity: 1; background: rgba(255,255,255,0.1); }

        .new-tab-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px dashed #444;
            border-radius: 6px;
            color: #666;
            font-size: 18px;
            cursor: pointer;
            flex-shrink: 0;
        }
        .new-tab-btn:hover { background: #16213e; color: #888; border-color: #666; }

        .player-link {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid #444;
            border-radius: 6px;
            color: #666;
            font-size: 13px;
            cursor: pointer;
            text-decoration: none;
            flex-shrink: 0;
        }
        .player-link:hover { background: #16213e; color: #888; border-color: #666; }

        /* Mobile dropdown */
        .mobile-session-select {
            display: none;
            flex: 1;
            padding: 8px 12px;
            background: #16213e;
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        @media (max-width: 600px) {
            .tab { display: none; }
            .mobile-session-select { display: block; }
        }

        /* Main content area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            position: relative;
        }

        /* Session container - each session gets its own container */
        .session-container {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            flex-direction: column;
        }
        .session-container.active {
            display: flex;
        }

        /* Connection screen */
        .connect-screen {
            display: none;
            flex: 1;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .connect-screen.active { display: flex; }

        .connect-box {
            width: 100%;
            max-width: 400px;
            padding-top: 40px;
            padding-bottom: 40px;
        }
        /* Center vertically only on tall screens */
        @media (min-height: 600px) {
            .connect-box {
                padding-top: 0;
                padding-bottom: 0;
                margin-top: auto;
                margin-bottom: auto;
            }
        }

        .connect-title {
            color: #fff;
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 20px;
            text-align: center;
        }

        .status-text {
            color: #888;
            font-size: 14px;
            text-align: center;
            margin-bottom: 16px;
        }
        .status-text.error { color: #ff6b6b; }
        .status-text.success { color: #4ecdc4; }

        .form-row {
            margin-bottom: 16px;
        }
        .form-row label {
            color: #888;
            font-size: 13px;
            display: block;
            margin-bottom: 6px;
        }
        .form-row input {
            width: 100%;
            padding: 12px;
            background: #0f0f1a;
            border: 1px solid #333;
            border-radius: 6px;
            color: #fff;
            font-size: 16px;
        }
        .form-row input:focus {
            outline: none;
            border-color: #4ecdc4;
        }
        .form-row input.code-input {
            font-size: 20px;
            text-align: center;
            letter-spacing: 4px;
            text-transform: uppercase;
            font-family: monospace;
        }
        .form-row input::placeholder { color: #555; }

        .password-wrapper {
            position: relative;
            display: flex;
        }
        .password-wrapper input {
            flex: 1;
            padding-right: 44px;
        }
        .password-toggle {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 4px 8px;
            font-size: 12px;
        }
        .password-toggle:hover { color: #999; }

        .form-row.optional label::after {
            content: ' (optional)';
            color: #555;
            font-weight: normal;
        }

        .connect-btn {
            width: 100%;
            padding: 14px;
            background: #4ecdc4;
            border: none;
            border-radius: 6px;
            color: #000;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 8px;
        }
        .connect-btn:hover { background: #3dbdb5; }
        .connect-btn:disabled { background: #333; color: #666; cursor: not-allowed; }

        /* Recent sessions */
        .recent-sessions {
            margin-bottom: 20px;
        }
        .recent-sessions-title {
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .recent-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: #0f0f1a;
            border: 1px solid #222;
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
        }
        .recent-item:hover { border-color: #444; }
        .recent-item .name { flex: 1; color: #fff; font-size: 14px; }
        .recent-item .code { color: #666; font-size: 12px; font-family: monospace; }
        .recent-item .delete {
            color: #666;
            margin-left: 8px;
            padding: 4px;
            opacity: 0;
        }
        .recent-item:hover .delete { opacity: 1; }
        .recent-item .delete:hover { color: #ff6b6b; }

        .divider {
            border-top: 1px solid #222;
            margin: 16px 0;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid #333;
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 20px auto;
        }
        .spinner.hidden { display: none; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Mobile responsive adjustments for connect screen */
        @media (max-width: 480px) {
            .connect-screen { padding: 16px; }
            .connect-title { font-size: 16px; margin-bottom: 16px; }
            .form-row { margin-bottom: 12px; }
            .form-row input { padding: 10px; }
            .connect-btn { padding: 12px; }
            .recent-item { padding: 8px 10px; }
            .recent-item .delete { opacity: 0.6; } /* Always visible on touch */
        }
        /* Very short screens (landscape phones) */
        @media (max-height: 400px) {
            .connect-screen { padding: 12px; }
            .connect-box { padding-top: 8px; padding-bottom: 8px; }
            .connect-title { font-size: 14px; margin-bottom: 12px; }
            .form-row { margin-bottom: 8px; }
            .form-row input { padding: 8px; }
            .connect-btn { padding: 10px; }
            .recent-sessions { margin-bottom: 12px; }
            .recent-item { padding: 6px 8px; margin-bottom: 4px; }
        }

        /* Terminal container */
        .terminal-screen {
            display: none;
            flex: 1;
            flex-direction: column;
            min-height: 0;
        }
        .terminal-screen.active { display: flex; }

        .terminal-container {
            flex: 1;
            padding: 4px;
            position: relative;
            min-height: 0;
        }
        .terminal-container .xterm { height: 100%; }

        /* Mobile keyboard helper */
        .mobile-input {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0;
            font-size: 16px;
            z-index: 10;
            pointer-events: none;
        }
        .mobile-input.active { pointer-events: auto; }

        /* Status bar */
        .status-bar {
            background: #0f0f1a;
            border-top: 1px solid #2a2a4a;
            padding: 6px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        .status-bar-left {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
        }
        .status-bar-left .latency { color: #4ecdc4; }
        .status-bar-left .latency.warn { color: #f9ca24; }
        .status-bar-left .latency.bad { color: #ff6b6b; }
        .status-bar-left .read-only-badge {
            background: #f9ca24;
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 11px;
        }

        /* Viewer mode styling */
        .terminal-screen.viewer-mode .terminal-container {
            border: 2px solid #f9ca24;
            border-radius: 4px;
        }
        .terminal-screen.viewer-mode::before {
            content: 'üëÅ VIEWING - Read Only';
            display: block;
            background: linear-gradient(90deg, #f9ca24, #f0932b);
            color: #000;
            text-align: center;
            padding: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        .tab.viewer .tab-name::after {
            content: ' üëÅ';
            opacity: 0.7;
        }

        .status-bar-right {
            display: flex;
            gap: 8px;
        }
        .status-bar button {
            background: #16213e;
            border: 1px solid #2a2a4a;
            color: #888;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .status-bar button:hover { background: #1a2a4e; color: #fff; }
        .status-bar button.reconnect-btn { border-color: #e94560; color: #e94560; }
        .status-bar button.reconnect-btn:hover { background: #e94560; color: #fff; }

        /* Loading spinner */
        .spinner {
            border: 3px solid #16213e; border-top: 3px solid #e94560;
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Rename input overlay */
        .rename-input {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            padding: 6px 8px;
            background: #16213e;
            border: 2px solid #e94560;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
            z-index: 100;
        }

        .hidden { display: none !important; }

        /* Keyboard shortcut hints */
        .shortcuts-hint {
            position: fixed;
            bottom: 50px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            color: #888;
            display: none;
        }
        .shortcuts-hint.show { display: block; }
        .shortcuts-hint kbd {
            background: #16213e;
            padding: 2px 6px;
            border-radius: 3px;
            color: #fff;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Tab Bar -->
        <div class="tab-bar">
            <div id="tabs-container"></div>
            <select class="mobile-session-select" id="mobile-select"></select>
            <button class="new-tab-btn" id="new-tab-btn" title="New Session (Ctrl+T)">+</button>
            <a class="player-link" href="player.html" title="Recording Playback">‚ñ∂ Play</a>
        </div>

        <!-- Main Content Area -->
        <div class="main-content" id="main-content">
            <!-- Sessions are dynamically added here -->
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-bar-left">
                <span id="connection-status">No active session</span>
                <span class="latency" id="latency"></span>
                <span class="read-only-badge hidden" id="read-only-badge">READ-ONLY</span>
            </div>
            <div class="status-bar-right">
                <button id="reconnect-btn" class="reconnect-btn hidden">Reconnect</button>
                <button id="fullscreen-btn" title="Fullscreen">‚õ∂</button>
            </div>
        </div>
    </div>

    <div class="shortcuts-hint" id="shortcuts-hint">
        <div><kbd>Ctrl+T</kbd> New session</div>
        <div><kbd>Ctrl+W</kbd> Close session</div>
        <div><kbd>Ctrl+1-9</kbd> Switch tabs</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/argon2-browser@1.18.0/dist/argon2-bundled.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <script>
    (function() {
        'use strict';

        const DEFAULT_RELAY_URL = 'https://terminal-tunnel-relay.artpar.workers.dev';

        // Get relay URL from URL parameter or use default
        // Usage: ?relay=https://your-relay.workers.dev
        function getRelayURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('relay') || DEFAULT_RELAY_URL;
        }
        const RELAY_URL = getRelayURL();

        const STORAGE_KEY = 'tt_sessions';
        const MSG_DATA = 0x01, MSG_RESIZE = 0x02, MSG_PING = 0x03, MSG_PONG = 0x04, MSG_CLOSE = 0x05;
        const COMPACT_VERSION = 0x01, SALT_SIZE = 16;

        // ICE servers - fetched from relay (includes TURN if configured)
        // Falls back to default STUN servers if fetch fails
        let cachedICEServers = null;

        async function fetchICEServers(relayUrl) {
            if (cachedICEServers) return cachedICEServers;
            try {
                const resp = await fetch(`${relayUrl}/ice-servers`);
                if (resp.ok) {
                    const data = await resp.json();
                    cachedICEServers = data.iceServers;
                    if (data.hasTurn) {
                        console.log('[ICE] TURN relay available for symmetric NAT');
                    }
                    return cachedICEServers;
                }
            } catch (e) {
                console.log('[ICE] Failed to fetch ICE servers, using defaults');
            }
            // Fallback to default STUN servers
            return [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ];
        }

        // Security: HTML escape function to prevent XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============== Session Class ==============
        class Session {
            constructor(id) {
                this.id = id;
                this.code = null;
                this.name = null;
                this.relayUrl = RELAY_URL;
                this.connectionMode = 'code';
                this.status = 'new'; // new, connecting, connected, disconnected
                this.pc = null;
                this.dc = null;
                this.term = null;
                this.fitAddon = null;
                this.encryptionKey = null;
                this.salt = null;
                this.container = null;
                this.connectScreen = null;
                this.terminalScreen = null;
                this.latency = null;
                this.lastPingTime = null;
                this.lastPongTime = null;
                this.pingInterval = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.password = null; // Stored for auto-reconnect only
                this.readOnly = false; // True for viewer sessions (code ends with V)
                this.disconnectTimer = null; // Timer for delayed disconnect on 'disconnected' state
            }

            // Check if this is a viewer session (code ends with V)
            isViewer() {
                return this.code && this.code.toUpperCase().endsWith('V');
            }

            destroy() {
                if (this.pingInterval) clearInterval(this.pingInterval);
                if (this.disconnectTimer) clearTimeout(this.disconnectTimer);
                if (this.dc) this.dc.close();
                if (this.pc) this.pc.close();
                if (this.term) this.term.dispose();
                if (this.container) this.container.remove();
                this.password = null; // Clear password on destroy
            }
        }

        // ============== SessionManager Class ==============
        class SessionManager {
            constructor() {
                this.sessions = new Map();
                this.activeId = null;
                this.savedSessions = this.loadSavedSessions();
            }

            loadSavedSessions() {
                try {
                    return JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
                } catch { return []; }
            }

            saveSessions() {
                const toSave = this.savedSessions.map(s => ({
                    id: s.id, code: s.code, name: s.name,
                    relayUrl: s.relayUrl, lastConnected: s.lastConnected,
                    connectionMode: s.connectionMode
                }));
                localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
            }

            saveSession(session) {
                const existing = this.savedSessions.findIndex(s => s.code === session.code);
                const data = {
                    id: session.id,
                    code: session.code,
                    name: session.name || session.code,
                    relayUrl: session.relayUrl,
                    lastConnected: Date.now(),
                    connectionMode: session.connectionMode
                };
                if (existing >= 0) {
                    this.savedSessions[existing] = { ...this.savedSessions[existing], ...data };
                } else {
                    this.savedSessions.unshift(data);
                    if (this.savedSessions.length > 10) this.savedSessions.pop();
                }
                this.saveSessions();
            }

            deleteSavedSession(code) {
                this.savedSessions = this.savedSessions.filter(s => s.code !== code);
                this.saveSessions();
                // Also delete saved password
                this.deletePassword(code);
            }

            // Password storage (separate from session data)
            getSavedPassword(code) {
                try {
                    const passwords = JSON.parse(localStorage.getItem(STORAGE_KEY + '_passwords')) || {};
                    return passwords[code] || '';
                } catch { return ''; }
            }

            savePassword(code, password) {
                try {
                    const passwords = JSON.parse(localStorage.getItem(STORAGE_KEY + '_passwords')) || {};
                    passwords[code] = password;
                    localStorage.setItem(STORAGE_KEY + '_passwords', JSON.stringify(passwords));
                } catch {}
            }

            deletePassword(code) {
                try {
                    const passwords = JSON.parse(localStorage.getItem(STORAGE_KEY + '_passwords')) || {};
                    delete passwords[code];
                    localStorage.setItem(STORAGE_KEY + '_passwords', JSON.stringify(passwords));
                } catch {}
            }

            createSession() {
                const id = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const session = new Session(id);
                this.sessions.set(id, session);
                return session;
            }

            getSession(id) {
                return this.sessions.get(id);
            }

            getActiveSession() {
                return this.activeId ? this.sessions.get(this.activeId) : null;
            }

            setActive(id) {
                this.activeId = id;
                this.sessions.forEach((s, sid) => {
                    if (s.container) {
                        s.container.classList.toggle('active', sid === id);
                    }
                });
                this.updateUI();
            }

            removeSession(id) {
                const session = this.sessions.get(id);
                if (session) {
                    session.destroy();
                    this.sessions.delete(id);
                }
                if (this.activeId === id) {
                    const remaining = Array.from(this.sessions.keys());
                    this.activeId = remaining.length > 0 ? remaining[0] : null;
                }
                this.updateUI();
            }

            updateUI() {
                renderTabs();
                renderMobileSelect();
                updateStatusBar();
            }
        }

        const manager = new SessionManager();

        // ============== DOM References ==============
        const tabsContainer = document.getElementById('tabs-container');
        const mobileSelect = document.getElementById('mobile-select');
        const mainContent = document.getElementById('main-content');
        const newTabBtn = document.getElementById('new-tab-btn');
        const reconnectBtn = document.getElementById('reconnect-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const connectionStatusEl = document.getElementById('connection-status');
        const latencyEl = document.getElementById('latency');

        // ============== Initialization ==============
        function init() {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('c') || params.get('code');

            if (code) {
                const session = manager.createSession();
                session.code = code.toUpperCase();
                manager.setActive(session.id);
                createSessionUI(session);

                // Check if this is a viewer session (code ends with V)
                if (session.isViewer()) {
                    session.readOnly = true;
                    // Viewer mode - connect directly without password
                    startViewerConnection(session);
                } else {
                    showConnectScreen(session, 'password');
                }
            } else {
                showNewSessionDialog();
            }

            setupEventListeners();
        }

        // ============== UI Rendering ==============
        function renderTabs() {
            tabsContainer.innerHTML = '';
            manager.sessions.forEach((session, id) => {
                const tab = document.createElement('div');
                tab.className = 'tab' + (id === manager.activeId ? ' active' : '') + (session.readOnly ? ' viewer' : '');
                tab.dataset.id = id;

                const statusClass = session.status === 'connected' ? 'connected' :
                                   session.status === 'connecting' ? 'connecting' : 'disconnected';

                // Security: Use DOM methods instead of innerHTML to prevent XSS
                const statusDot = document.createElement('span');
                statusDot.className = 'status-dot ' + statusClass;

                const tabName = document.createElement('span');
                tabName.className = 'tab-name';
                tabName.textContent = session.name || session.code || 'New Session'; // Safe: textContent escapes HTML

                const closeBtn = document.createElement('span');
                closeBtn.className = 'close-btn';
                closeBtn.dataset.action = 'close';
                closeBtn.textContent = '√ó';

                tab.appendChild(statusDot);
                tab.appendChild(tabName);
                tab.appendChild(closeBtn);

                tab.addEventListener('click', (e) => {
                    if (e.target.dataset.action === 'close') {
                        if (manager.sessions.size > 1 || session.status !== 'connected') {
                            manager.removeSession(id);
                            if (manager.sessions.size === 0) showNewSessionDialog();
                        }
                    } else {
                        manager.setActive(id);
                    }
                });

                tab.addEventListener('dblclick', (e) => {
                    if (e.target.classList.contains('tab-name')) {
                        startRename(session, e.target);
                    }
                });

                tabsContainer.appendChild(tab);
            });
        }

        function renderMobileSelect() {
            mobileSelect.innerHTML = '';
            manager.sessions.forEach((session, id) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = session.name || session.code || 'New Session';
                option.selected = id === manager.activeId;
                mobileSelect.appendChild(option);
            });
        }

        function startRename(session, element) {
            const rect = element.getBoundingClientRect();
            const input = document.createElement('input');
            input.className = 'rename-input';
            input.value = session.name || session.code || '';
            input.style.top = rect.top + 'px';
            input.style.left = rect.left + 'px';
            input.style.width = rect.width + 'px';

            document.body.appendChild(input);
            input.focus();
            input.select();

            const finish = () => {
                const newName = input.value.trim();
                if (newName) {
                    session.name = newName;
                    manager.saveSession(session);
                }
                input.remove();
                renderTabs();
            };

            input.addEventListener('blur', finish);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') finish();
                if (e.key === 'Escape') input.remove();
            });
        }

        function updateStatusBar() {
            const session = manager.getActiveSession();
            if (!session) {
                connectionStatusEl.textContent = 'No active session';
                latencyEl.textContent = '';
                reconnectBtn.classList.add('hidden');
                return;
            }

            const statusText = {
                'new': 'Ready to connect',
                'connecting': session.readOnly ? 'Connecting as viewer...' : 'Connecting...',
                'connected': session.readOnly ? 'üëÅ Viewing' : '‚óè Connected',
                'disconnected': '‚óã Disconnected'
            };

            connectionStatusEl.textContent = statusText[session.status] || session.status;
            connectionStatusEl.style.color = session.status === 'connected' ? '#4ecdc4' :
                                             session.status === 'connecting' ? '#f9ca24' : '#ff6b6b';

            if (session.latency !== null && session.status === 'connected') {
                latencyEl.textContent = `${session.latency}ms`;
                latencyEl.className = 'latency' + (session.latency > 500 ? ' bad' : session.latency > 100 ? ' warn' : '');
            } else {
                latencyEl.textContent = '';
            }

            reconnectBtn.classList.toggle('hidden', session.status !== 'disconnected' || !session.code);

            // Show read-only badge for viewer sessions
            const readOnlyBadge = document.getElementById('read-only-badge');
            readOnlyBadge.classList.toggle('hidden', !session.readOnly);
        }

        // ============== Session UI Creation ==============
        function createSessionUI(session) {
            const container = document.createElement('div');
            container.className = 'session-container';
            container.id = 'session-' + session.id;

            container.innerHTML = `
                <div class="connect-screen">
                    <div class="connect-box">
                        <div class="connect-title">Terminal Tunnel</div>
                        <div class="status-text">Enter session details</div>
                        <div class="form-area"></div>
                        <div class="spinner hidden"></div>
                    </div>
                </div>
                <div class="terminal-screen">
                    <div class="terminal-container">
                        <input type="text" class="mobile-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="text">
                    </div>
                </div>
            `;

            mainContent.appendChild(container);
            session.container = container;
            session.connectScreen = container.querySelector('.connect-screen');
            session.terminalScreen = container.querySelector('.terminal-screen');

            if (session.id === manager.activeId) {
                container.classList.add('active');
            }

            renderTabs();
        }

        function showConnectScreen(session, mode = 'full') {
            session.connectScreen.classList.add('active');
            session.terminalScreen.classList.remove('active');

            const formArea = session.connectScreen.querySelector('.form-area');
            const statusText = session.connectScreen.querySelector('.status-text');

            if (mode === 'password') {
                statusText.textContent = `Session: ${session.code}`;
                const savedPassword = manager.getSavedPassword(session.code);
                formArea.innerHTML = `
                    <div class="form-row optional">
                        <label>Name</label>
                        <input type="text" class="name-input" placeholder="e.g., Dev Server" value="${escapeHtml(session.name || '')}">
                    </div>
                    <div class="form-row">
                        <label>Password</label>
                        <div class="password-wrapper">
                            <input type="password" class="password-input" placeholder="Session password" autocomplete="off" value="${escapeHtml(savedPassword)}">
                            <button type="button" class="password-toggle">Show</button>
                        </div>
                    </div>
                    <button class="connect-btn">Connect</button>
                `;
            } else {
                const recentHtml = manager.savedSessions.length > 0 ? `
                    <div class="recent-sessions">
                        <div class="recent-sessions-title">Recent</div>
                        ${manager.savedSessions.map(s => `
                            <div class="recent-item" data-code="${escapeHtml(s.code)}" data-name="${escapeHtml(s.name || '')}" data-relay="${escapeHtml(s.relayUrl || RELAY_URL)}">
                                <span class="name">${escapeHtml(s.name || s.code)}</span>
                                <span class="code">${escapeHtml(s.code)}</span>
                                <span class="delete" data-action="delete">&times;</span>
                            </div>
                        `).join('')}
                    </div>
                    <div class="divider"></div>
                ` : '';

                statusText.textContent = '';
                formArea.innerHTML = `
                    ${recentHtml}
                    <div class="form-row">
                        <label>Code</label>
                        <input type="text" class="code-input" placeholder="ABCD1234" maxlength="8" autocomplete="off" value="${escapeHtml(session.code || '')}">
                    </div>
                    <div class="form-row">
                        <label>Password</label>
                        <div class="password-wrapper">
                            <input type="password" class="password-input" placeholder="Session password" autocomplete="off">
                            <button type="button" class="password-toggle">Show</button>
                        </div>
                    </div>
                    <div class="form-row optional">
                        <label>Name</label>
                        <input type="text" class="name-input" placeholder="e.g., Dev Server">
                    </div>
                    <button class="connect-btn">Connect</button>
                `;
            }

            // Event listeners
            const connectBtn = formArea.querySelector('.connect-btn');
            const passwordInput = formArea.querySelector('.password-input');
            const passwordToggle = formArea.querySelector('.password-toggle');
            const codeInput = formArea.querySelector('.code-input');
            const nameInput = formArea.querySelector('.name-input');

            connectBtn.addEventListener('click', () => startConnection(session, formArea));
            passwordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') startConnection(session, formArea);
            });

            // Password show/hide toggle
            if (passwordToggle) {
                passwordToggle.addEventListener('click', () => {
                    const isPassword = passwordInput.type === 'password';
                    passwordInput.type = isPassword ? 'text' : 'password';
                    passwordToggle.textContent = isPassword ? 'Hide' : 'Show';
                });
            }

            if (codeInput) {
                codeInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') passwordInput.focus();
                });
            }

            // Recent session click handlers
            formArea.querySelectorAll('.recent-item').forEach(el => {
                el.addEventListener('click', (e) => {
                    if (e.target.dataset.action === 'delete') {
                        e.stopPropagation();
                        manager.deleteSavedSession(el.dataset.code);
                        el.remove();
                        // Remove recent section if empty
                        const recentSection = formArea.querySelector('.recent-sessions');
                        if (recentSection && recentSection.querySelectorAll('.recent-item').length === 0) {
                            recentSection.remove();
                            const divider = formArea.querySelector('.divider');
                            if (divider) divider.remove();
                        }
                        return;
                    }
                    if (codeInput) codeInput.value = el.dataset.code;
                    if (nameInput) nameInput.value = el.dataset.name;
                    session.relayUrl = el.dataset.relay;
                    // Load saved password for this session
                    const savedPwd = manager.getSavedPassword(el.dataset.code);
                    if (savedPwd) passwordInput.value = savedPwd;
                    passwordInput.focus();
                });
            });

            setTimeout(() => (codeInput || passwordInput).focus(), 100);
        }

        function showNewSessionDialog() {
            const session = manager.createSession();
            manager.setActive(session.id);
            createSessionUI(session);
            showConnectScreen(session, 'full');
        }

        // ============== Connection Logic ==============

        // Viewer connection - no password needed, key is fetched from relay
        async function startViewerConnection(session) {
            session.status = 'connecting';
            manager.updateUI();

            const statusText = session.connectScreen.querySelector('.status-text');
            const spinner = session.connectScreen.querySelector('.spinner');
            session.connectScreen.classList.add('active');
            spinner.classList.remove('hidden');

            try {
                statusText.textContent = 'Fetching viewer session...';
                const response = await fetch(`${session.relayUrl}/session/${session.code}`);
                if (!response.ok) {
                    throw new Error(response.status === 404 ? 'Session not found or expired' : 'Failed to fetch session');
                }
                const data = await response.json();

                if (!data.read_only || !data.key) {
                    throw new Error('Invalid viewer session');
                }

                // Use session-specific ICE servers for consistent TURN credentials
                session.iceServers = data.iceServers;

                // Use the key directly from the relay (no password derivation needed)
                statusText.textContent = 'Connecting (read-only mode)...';
                session.encryptionKey = base64ToBytes(data.key);
                session.name = session.code + ' (Viewer)';

                statusText.textContent = 'Establishing connection...';
                await establishConnection(session, data.sdp, session.code);

            } catch (err) {
                statusText.textContent = 'Error: ' + err.message;
                statusText.classList.add('error');
                session.status = 'disconnected';
                spinner.classList.add('hidden');
                manager.updateUI();
            }
        }

        async function startConnection(session, formArea) {
            const codeInput = formArea.querySelector('.code-input');
            const passwordInput = formArea.querySelector('.password-input');
            const nameInput = formArea.querySelector('.name-input');
            const connectBtn = formArea.querySelector('.connect-btn');
            const spinner = session.connectScreen.querySelector('.spinner');
            const statusText = session.connectScreen.querySelector('.status-text');

            const code = (codeInput ? codeInput.value : session.code || '').trim().toUpperCase();
            const password = passwordInput.value;
            const name = nameInput ? nameInput.value.trim() : '';

            if (!code || code.length < 4) {
                statusText.textContent = 'Please enter a valid session code';
                statusText.classList.add('error');
                return;
            }
            if (!password) {
                statusText.textContent = 'Please enter a password';
                statusText.classList.add('error');
                return;
            }

            session.code = code;
            session.name = name || code;
            session.password = password; // Store for auto-reconnect
            session.status = 'connecting';
            connectBtn.disabled = true;
            spinner.classList.remove('hidden');
            statusText.classList.remove('error');
            manager.updateUI();

            try {
                statusText.textContent = 'Fetching session...';
                const response = await fetch(`${session.relayUrl}/session/${code}`);
                if (!response.ok) {
                    throw new Error(response.status === 404 ? 'Session not found or expired' : 'Failed to fetch session');
                }
                const data = await response.json();
                session.salt = base64ToBytes(data.salt || '');
                // Use session-specific ICE servers for consistent TURN credentials
                session.iceServers = data.iceServers;

                statusText.textContent = 'Deriving encryption key...';
                session.encryptionKey = await deriveKey(password, session.salt);

                statusText.textContent = 'Establishing connection...';
                await establishConnection(session, data.sdp, code);

            } catch (err) {
                statusText.textContent = 'Error: ' + err.message;
                statusText.classList.add('error');
                session.status = 'disconnected';
                connectBtn.disabled = false;
                spinner.classList.add('hidden');
                manager.updateUI();
            }
        }

        async function establishConnection(session, offerSdp, code) {
            const statusText = session.connectScreen.querySelector('.status-text');

            // Use session-specific ICE servers (includes TURN with credentials tied to session)
            // This ensures both server and client use the same TURN credentials
            const iceServers = session.iceServers || await fetchICEServers(session.relayUrl);
            console.log('[ICE] Configured servers:', JSON.stringify(iceServers.map(s => ({
                urls: s.urls,
                hasCredential: !!s.credential
            }))));
            session.pc = new RTCPeerConnection({ iceServers });

            // Track gathered candidates for debugging
            let candidateCounts = { host: 0, srflx: 0, relay: 0 };
            session.pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const type = event.candidate.type || 'unknown';
                    candidateCounts[type] = (candidateCounts[type] || 0) + 1;
                    if (type === 'relay') {
                        console.log('[ICE] Gathered TURN relay candidate:', event.candidate.address);
                    }
                } else {
                    // Null candidate means gathering is complete
                    console.log('[ICE] Gathering complete. Candidates:', JSON.stringify(candidateCounts));
                }
            };

            session.pc.ondatachannel = (event) => {
                session.dc = event.channel;
                setupDataChannel(session);
            };

            session.pc.onconnectionstatechange = () => {
                const state = session.pc.connectionState;
                console.log('[PC] Connection state:', state, 'dc state:', session.dc?.readyState);
                if (state === 'failed') {
                    // Connection truly failed - disconnect and reconnect
                    handleDisconnect(session, true);
                } else if (state === 'disconnected') {
                    // 'disconnected' is transient and can recover - wait before giving up
                    // Clear any existing disconnect timer
                    if (session.disconnectTimer) {
                        clearTimeout(session.disconnectTimer);
                    }
                    console.log('[PC] Connection disconnected, waiting 15s for recovery...');
                    session.disconnectTimer = setTimeout(() => {
                        // If still disconnected after 15 seconds, trigger reconnect
                        if (session.pc && session.pc.connectionState === 'disconnected') {
                            console.log('[PC] Connection did not recover, triggering reconnect');
                            handleDisconnect(session, true);
                        }
                    }, 15000);
                } else if (state === 'connected') {
                    // Connection recovered - cancel any pending disconnect
                    if (session.disconnectTimer) {
                        clearTimeout(session.disconnectTimer);
                        session.disconnectTimer = null;
                        console.log('[PC] Connection recovered!');
                    }
                }
            };

            session.pc.oniceconnectionstatechange = () => {
                console.log('[ICE] Connection state:', session.pc.iceConnectionState);

                // ICE stall detection: if checking takes > 5 seconds, force restart with fresh session
                if (session.pc.iceConnectionState === 'checking') {
                    // Clear any existing stall timer to prevent multiple timers
                    if (session.iceStallTimer) {
                        clearTimeout(session.iceStallTimer);
                    }
                    session.iceCheckingStart = Date.now();
                    const currentPc = session.pc; // Capture current peer connection
                    session.iceStallTimer = setTimeout(async () => {
                        // Only trigger if this is still the same peer connection and still checking
                        if (session.pc === currentPc && session.pc.iceConnectionState === 'checking') {
                            console.log('[ICE] Connection stalled in checking state, forcing retry with fresh session');
                            // Close current connection
                            if (session.pc) {
                                try { session.pc.close(); } catch(e) {}
                                session.pc = null;
                            }
                            if (session.dc) {
                                try { session.dc.close(); } catch(e) {}
                                session.dc = null;
                            }
                            session.status = 'disconnected';
                            // Small delay to ensure server has updated session with new offer
                            await new Promise(r => setTimeout(r, 500));
                            // Retry with fresh session fetch
                            attemptAutoReconnect(session);
                        }
                    }, 30000); // 30 second stall threshold - TURN relay needs time
                } else if (session.pc.iceConnectionState === 'connected' ||
                           session.pc.iceConnectionState === 'completed') {
                    // ICE succeeded - clear stall timer
                    if (session.iceStallTimer) {
                        clearTimeout(session.iceStallTimer);
                        session.iceStallTimer = null;
                    }
                    if (session.iceCheckingStart) {
                        console.log('[ICE] Connection established in', Date.now() - session.iceCheckingStart, 'ms');
                        session.iceCheckingStart = null;
                    }
                } else if (session.pc.iceConnectionState === 'failed' ||
                           session.pc.iceConnectionState === 'disconnected') {
                    // ICE failed - clear stall timer (reconnect will be triggered by pc state change)
                    if (session.iceStallTimer) {
                        clearTimeout(session.iceStallTimer);
                        session.iceStallTimer = null;
                    }
                }
            };

            await session.pc.setRemoteDescription({ type: 'offer', sdp: offerSdp });
            const answer = await session.pc.createAnswer();
            await session.pc.setLocalDescription(answer);
            await waitForICE(session.pc);

            statusText.textContent = 'Sending answer...';
            const resp = await fetch(`${session.relayUrl}/session/${code}/answer`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sdp: session.pc.localDescription.sdp })
            });

            if (!resp.ok) throw new Error('Failed to submit answer');

            statusText.textContent = 'Waiting for connection...';

            // Backup timeout in case ICE stall detection doesn't trigger
            setTimeout(() => {
                if (session.status === 'connecting') {
                    console.log('[Connection] Timeout reached, triggering auto-reconnect');
                    // Clean up and trigger reconnect
                    if (session.pc) { try { session.pc.close(); } catch(e) {} session.pc = null; }
                    if (session.dc) { try { session.dc.close(); } catch(e) {} session.dc = null; }
                    session.status = 'disconnected';
                    attemptAutoReconnect(session);
                }
            }, 30000); // 30 second backup timeout to allow TURN relay time on mobile networks
        }

        function setupDataChannel(session) {
            session.dc.binaryType = 'arraybuffer';

            session.dc.onopen = () => {
                console.log('[DC] Data channel opened, readyState:', session.dc.readyState);
                session.status = 'connected';
                // Clear all reconnection state on successful connection
                if (session.reconnectAttempts > 0) {
                    console.log('Reconnected successfully after', session.reconnectAttempts, 'attempt(s)');
                }
                session.reconnectAttempts = 0;
                session.reconnectInProgress = false;
                if (session.reconnectTimer) {
                    clearTimeout(session.reconnectTimer);
                    session.reconnectTimer = null;
                }
                // Reset latency tracking for fresh measurement
                session.latency = null;
                session.lastPingTime = Date.now();
                session.lastPongTime = Date.now();
                // Send immediate ping to let server know our encryption key (Argon2 vs PBKDF2)
                sendMessage(session, MSG_PING, new Uint8Array(0));
                manager.saveSession(session);
                // Save password for quick reconnect
                if (session.password) {
                    manager.savePassword(session.code, session.password);
                }
                showTerminal(session);
                startPingInterval(session);
                manager.updateUI();
                // Refresh mobile viewport after connection (keyboard may have changed)
                if (window.refreshMobileViewport) window.refreshMobileViewport();
                console.log('[DC] Data channel setup complete');
            };

            session.dc.onclose = () => {
                console.log('[DC] Data channel closed! readyState:', session.dc?.readyState, 'pc state:', session.pc?.connectionState);
                handleDisconnect(session, true); // Auto-reconnect on dc close
            };

            session.dc.onerror = (err) => {
                console.error('[DC] Data channel error:', err);
            };

            session.dc.onmessage = async (event) => {
                try {
                    const decrypted = await decrypt(session, new Uint8Array(event.data));
                    const msg = parseMessage(decrypted);

                    if (msg.type === MSG_DATA) {
                        session.term.write(new Uint8Array(msg.payload));
                    } else if (msg.type === MSG_PING) {
                        sendMessage(session, MSG_PONG, new Uint8Array(0));
                    } else if (msg.type === MSG_PONG) {
                        session.lastPongTime = Date.now();
                        if (session.lastPingTime) {
                            session.latency = Date.now() - session.lastPingTime;
                            manager.updateUI();
                        }
                    } else if (msg.type === MSG_CLOSE) {
                        session.dc.close();
                    }
                } catch (err) { /* ignore decryption errors */ }
            };
        }

        function handleDisconnect(session, autoReconnect = false) {
            if (session.status === 'disconnected') return; // Already disconnected
            // Don't interrupt an active reconnection attempt
            if (session.reconnectInProgress && session.status === 'connecting') {
                console.log('[handleDisconnect] Ignoring disconnect during active reconnection');
                return;
            }
            session.status = 'disconnected';
            // Clear latency tracking to avoid stale/wrong values on reconnect
            session.latency = null;
            session.lastPingTime = null;
            session.lastPongTime = null;
            if (session.pingInterval) {
                clearInterval(session.pingInterval);
                session.pingInterval = null;
            }
            if (session.disconnectTimer) {
                clearTimeout(session.disconnectTimer);
                session.disconnectTimer = null;
            }
            manager.updateUI();
            if (autoReconnect) {
                attemptAutoReconnect(session);
            }
        }

        const PONG_TIMEOUT = 35000; // 35 seconds without pong = connection dead (longer than server's 30s)
        const RECONNECT_BASE_DELAY = 1000; // Start with 1 second for faster initial reconnect
        const RECONNECT_MAX_DELAY = 30000; // Max 30 seconds

        function startPingInterval(session) {
            session.lastPongTime = Date.now(); // Initialize to now
            session.pingInterval = setInterval(() => {
                // Check for pong timeout FIRST (outside dc state check)
                if (session.lastPongTime && (Date.now() - session.lastPongTime) > PONG_TIMEOUT) {
                    console.log('Connection timed out - no pong received for', Date.now() - session.lastPongTime, 'ms');
                    handleDisconnect(session, true); // Auto-reconnect on timeout
                    return;
                }

                // Only send ping if data channel is open
                if (session.dc && session.dc.readyState === 'open') {
                    session.lastPingTime = Date.now();
                    sendMessage(session, MSG_PING, new Uint8Array(0));
                } else if (session.status === 'connected') {
                    // Data channel not open but we think we're connected - that's a problem
                    console.log('Data channel not open but status is connected, dc state:',
                        session.dc ? session.dc.readyState : 'no dc');
                }
            }, 10000); // Match server's 10s ping interval
        }

        function attemptAutoReconnect(session) {
            if (!session.code || !session.password) return; // Can't reconnect without credentials
            if (session.reconnectAttempts >= session.maxReconnectAttempts) {
                console.log('Max reconnect attempts reached');
                session.reconnectAttempts = 0;
                session.reconnectInProgress = false;
                return;
            }

            // Guard against multiple concurrent reconnection attempts
            if (session.reconnectInProgress) {
                console.log('Reconnection already in progress, skipping');
                return;
            }

            // Cancel any existing reconnect timer
            if (session.reconnectTimer) {
                clearTimeout(session.reconnectTimer);
                session.reconnectTimer = null;
            }

            session.reconnectAttempts++;

            // Use instant reconnect if triggered by visibility restore
            let delay;
            if (session.visibilityReconnect) {
                delay = 0; // Instant reconnect on visibility restore
                session.visibilityReconnect = false;
            } else {
                delay = Math.min(
                    RECONNECT_BASE_DELAY * Math.pow(2, session.reconnectAttempts - 1),
                    RECONNECT_MAX_DELAY
                );
            }

            console.log(`Auto-reconnecting in ${delay}ms (attempt ${session.reconnectAttempts}/${session.maxReconnectAttempts})`);

            session.reconnectTimer = setTimeout(async () => {
                session.reconnectTimer = null;
                if (session.status === 'disconnected' && session.code && !session.reconnectInProgress) {
                    session.reconnectInProgress = true;
                    session.status = 'connecting';
                    manager.updateUI();

                    // Clean up old connection
                    if (session.dc) { try { session.dc.close(); } catch(e) {} session.dc = null; }
                    if (session.pc) { try { session.pc.close(); } catch(e) {} session.pc = null; }

                    try {
                        // Fetch session from relay
                        const response = await fetch(`${session.relayUrl}/session/${session.code}`);
                        if (!response.ok) {
                            throw new Error(response.status === 404 ? 'Session expired' : 'Failed to fetch session');
                        }
                        const data = await response.json();
                        session.salt = base64ToBytes(data.salt || '');
                        // Use session-specific ICE servers for consistent TURN credentials
                        session.iceServers = data.iceServers;

                        // Re-derive key if salt changed, otherwise reuse
                        if (!session.encryptionKey) {
                            session.encryptionKey = await deriveKey(session.password, session.salt);
                        }

                        // Establish connection (success is handled in dc.onopen)
                        await establishConnection(session, data.sdp, session.code);
                        // Note: reconnectAttempts is reset in dc.onopen when truly connected
                        session.reconnectInProgress = false;
                    } catch (err) {
                        console.log('Reconnect failed:', err.message);
                        session.status = 'disconnected';
                        session.reconnectInProgress = false;
                        manager.updateUI();
                        attemptAutoReconnect(session); // Try again
                    }
                } else {
                    session.reconnectInProgress = false;
                }
            }, delay);
        }

        // ============== Terminal ==============
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        }

        function cleanupTerminal(session) {
            // Dispose old terminal and remove event listeners
            if (session.term) {
                try { session.term.dispose(); } catch(e) {}
                session.term = null;
            }
            if (session.fitAddon) {
                session.fitAddon = null;
            }
            // Clean up mobile input listeners (will be re-added if needed)
            const mobileInput = session.terminalScreen?.querySelector('.mobile-input');
            if (mobileInput && session.mobileInputHandler) {
                mobileInput.removeEventListener('input', session.mobileInputHandler);
                mobileInput.removeEventListener('keydown', session.mobileKeyHandler);
                session.mobileInputHandler = null;
                session.mobileKeyHandler = null;
            }
            // Clear the terminal container
            const termContainer = session.terminalScreen?.querySelector('.terminal-container');
            if (termContainer) {
                termContainer.innerHTML = '';
            }
        }

        function showTerminal(session) {
            session.connectScreen.classList.remove('active');
            session.terminalScreen.classList.add('active');

            // Add viewer mode class if read-only
            if (session.readOnly) {
                session.terminalScreen.classList.add('viewer-mode');
            }

            const termContainer = session.terminalScreen.querySelector('.terminal-container');
            const mobileInput = session.terminalScreen.querySelector('.mobile-input');
            const mobile = isMobile();

            // Clean up any existing terminal before creating new one
            cleanupTerminal(session);

            session.term = new Terminal({
                cursorBlink: !session.readOnly, // Don't blink cursor in read-only mode
                fontSize: mobile ? 12 : 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#1a1a2e',
                    foreground: '#e0e0e0',
                    cursor: session.readOnly ? '#888' : '#e94560' // Dim cursor in read-only mode
                },
                disableStdin: session.readOnly // Disable input in read-only mode
            });

            session.fitAddon = new FitAddon.FitAddon();
            session.term.loadAddon(session.fitAddon);
            session.term.open(termContainer);

            // Disable autocomplete/autocorrect on xterm's internal textarea (mobile keyboard fix)
            const xtermTextarea = termContainer.querySelector('textarea');
            if (xtermTextarea) {
                xtermTextarea.setAttribute('autocomplete', 'off');
                xtermTextarea.setAttribute('autocorrect', 'off');
                xtermTextarea.setAttribute('autocapitalize', 'off');
                xtermTextarea.setAttribute('spellcheck', 'false');
                xtermTextarea.setAttribute('data-gramm', 'false'); // Disable Grammarly
                xtermTextarea.setAttribute('data-gramm_editor', 'false');
            }

            session.fitAddon.fit();

            // Only send input if not in read-only mode
            if (!session.readOnly) {
                // Input coalescing: buffer keystrokes and send in batches (reduces overhead)
                let inputBuffer = '';
                let inputTimer = null;
                const COALESCE_MS = 16; // ~1 frame at 60fps

                session.term.onData((data) => {
                    inputBuffer += data;
                    if (!inputTimer) {
                        inputTimer = setTimeout(() => {
                            if (inputBuffer) {
                                sendMessage(session, MSG_DATA, new TextEncoder().encode(inputBuffer));
                                inputBuffer = '';
                            }
                            inputTimer = null;
                        }, COALESCE_MS);
                    }
                });
            }

            // Mobile input handling (disabled in read-only mode)
            if (mobile && !session.readOnly) {
                mobileInput.classList.add('active');
                // Mobile input coalescing
                let mobileBuffer = '';
                let mobileTimer = null;
                const MOBILE_COALESCE_MS = 16;

                const flushMobileBuffer = () => {
                    if (mobileBuffer) {
                        sendMessage(session, MSG_DATA, new TextEncoder().encode(mobileBuffer));
                        mobileBuffer = '';
                    }
                    mobileTimer = null;
                };

                const queueMobileInput = (data) => {
                    mobileBuffer += data;
                    if (!mobileTimer) {
                        mobileTimer = setTimeout(flushMobileBuffer, MOBILE_COALESCE_MS);
                    }
                };

                // Use named handlers so they can be removed on cleanup
                session.mobileInputHandler = (e) => {
                    if (e.target.value) {
                        queueMobileInput(e.target.value);
                        e.target.value = '';
                    }
                };
                session.mobileKeyHandler = (e) => {
                    let data = null;
                    switch (e.key) {
                        case 'Enter': data = '\r'; break;
                        case 'Backspace': data = '\x7f'; break;
                        case 'Tab': data = '\t'; e.preventDefault(); break;
                        case 'Escape': data = '\x1b'; break;
                        case 'ArrowUp': data = '\x1b[A'; break;
                        case 'ArrowDown': data = '\x1b[B'; break;
                        case 'ArrowRight': data = '\x1b[C'; break;
                        case 'ArrowLeft': data = '\x1b[D'; break;
                    }
                    if (data) {
                        queueMobileInput(data);
                        e.preventDefault();
                    }
                };
                mobileInput.addEventListener('input', session.mobileInputHandler);
                mobileInput.addEventListener('keydown', session.mobileKeyHandler);
                // These are idempotent - adding same listener multiple times is okay
                termContainer.addEventListener('touchstart', () => mobileInput.focus(), { passive: true });
                termContainer.addEventListener('click', () => mobileInput.focus());
            } else if (!session.readOnly) {
                termContainer.addEventListener('click', () => session.term.focus());
                session.term.focus();
            }

            // Resize handling (viewers don't send resize events - host controls terminal size)
            if (!session.readOnly) {
                session.term.onResize(({ rows, cols }) => {
                    const payload = new Uint8Array(4);
                    new DataView(payload.buffer).setUint16(0, rows, false);
                    new DataView(payload.buffer).setUint16(2, cols, false);
                    sendMessage(session, MSG_RESIZE, payload);
                });
            }

            window.addEventListener('resize', () => {
                if (session.fitAddon) session.fitAddon.fit();
            });

            setTimeout(() => {
                session.fitAddon.fit();
                // Only send initial resize for non-viewers
                if (!session.readOnly) {
                    const { rows, cols } = session.term;
                    const payload = new Uint8Array(4);
                    new DataView(payload.buffer).setUint16(0, rows, false);
                    new DataView(payload.buffer).setUint16(2, cols, false);
                    sendMessage(session, MSG_RESIZE, payload);
                }
            }, 100);
        }

        // ============== Crypto ==============
        // Flag to track if we're using PBKDF2 fallback (for status display)
        let usingPbkdf2Fallback = false;
        let argon2Checked = false;

        // Detect if we're on GitHub Pages or other CSP-restricted environments
        function isCSPRestricted() {
            const hostname = window.location.hostname;
            // GitHub Pages blocks WebAssembly via CSP
            if (hostname.endsWith('.github.io')) return true;
            // Add other known restricted hosts here
            return false;
        }

        // Initialize fallback detection immediately
        if (isCSPRestricted()) {
            console.log('GitHub Pages detected, using PBKDF2 (Argon2 WASM blocked by CSP)');
            usingPbkdf2Fallback = true;
            argon2Checked = true;
        }

        async function deriveKey(password, saltBytes) {
            // If not yet checked and not on restricted host, try argon2
            if (!argon2Checked && !usingPbkdf2Fallback) {
                argon2Checked = true;
                try {
                    if (typeof argon2 !== 'undefined' && argon2.hash) {
                        const result = await argon2.hash({
                            pass: password, salt: saltBytes,
                            time: 3, mem: 65536, parallelism: 4, hashLen: 32,
                            type: argon2.ArgonType.Argon2id
                        });
                        return new Uint8Array(result.hash);
                    }
                } catch (argonError) {
                    console.warn('Argon2 failed, using PBKDF2 fallback:', argonError.message);
                    usingPbkdf2Fallback = true;
                }
            }

            if (!usingPbkdf2Fallback && typeof argon2 !== 'undefined' && argon2.hash) {
                try {
                    const result = await argon2.hash({
                        pass: password, salt: saltBytes,
                        time: 3, mem: 65536, parallelism: 4, hashLen: 32,
                        type: argon2.ArgonType.Argon2id
                    });
                    return new Uint8Array(result.hash);
                } catch (argonError) {
                    console.warn('Argon2 failed, using PBKDF2 fallback:', argonError.message);
                    usingPbkdf2Fallback = true;
                }
            }

            // Fallback to PBKDF2 (Web Crypto API - works everywhere)
            return await deriveKeyPbkdf2(password, saltBytes);
        }

        async function deriveKeyPbkdf2(password, saltBytes) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw', encoder.encode(password), 'PBKDF2', false, ['deriveBits']
            );
            const derivedBits = await crypto.subtle.deriveBits(
                { name: 'PBKDF2', salt: saltBytes, iterations: 600000, hash: 'SHA-256' },
                keyMaterial, 256
            );
            return new Uint8Array(derivedBits);
        }

        async function encrypt(session, data) {
            const nonce = nacl.randomBytes(24);
            const encrypted = nacl.secretbox(data, nonce, session.encryptionKey);
            const result = new Uint8Array(nonce.length + encrypted.length);
            result.set(nonce);
            result.set(encrypted, nonce.length);
            return result;
        }

        async function decrypt(session, data) {
            const nonce = data.slice(0, 24);
            const ciphertext = data.slice(24);
            const decrypted = nacl.secretbox.open(ciphertext, nonce, session.encryptionKey);
            if (!decrypted) throw new Error('Decryption failed');
            return decrypted;
        }

        function parseMessage(data) {
            const type = data[0];
            const length = (data[1] << 8) | data[2];
            return { type, payload: data.slice(3, 3 + length) };
        }

        const MAX_BUFFER_SIZE = 64 * 1024; // 64KB backpressure threshold

        async function sendMessage(session, type, payload) {
            const msg = new Uint8Array(3 + payload.length);
            msg[0] = type;
            msg[1] = (payload.length >> 8) & 0xff;
            msg[2] = payload.length & 0xff;
            msg.set(payload, 3);
            const encrypted = await encrypt(session, msg);
            if (session.dc && session.dc.readyState === 'open') {
                // Backpressure: wait if buffer is too full
                if (session.dc.bufferedAmount > MAX_BUFFER_SIZE) {
                    await new Promise(resolve => {
                        const check = () => {
                            if (!session.dc || session.dc.readyState !== 'open') {
                                resolve();
                            } else if (session.dc.bufferedAmount <= MAX_BUFFER_SIZE / 2) {
                                resolve();
                            } else {
                                setTimeout(check, 10);
                            }
                        };
                        check();
                    });
                }
                if (session.dc && session.dc.readyState === 'open') {
                    session.dc.send(encrypted);
                }
            }
        }

        function base64ToBytes(base64) {
            try {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                return bytes;
            } catch { return new Uint8Array(0); }
        }

        function waitForICE(pc) {
            return new Promise((resolve) => {
                if (pc.iceGatheringState === 'complete') {
                    console.log('[ICE] Gathering already complete');
                    resolve();
                    return;
                }
                const check = () => {
                    console.log('[ICE] Gathering state:', pc.iceGatheringState);
                    if (pc.iceGatheringState === 'complete') {
                        pc.removeEventListener('icegatheringstatechange', check);
                        resolve();
                    }
                };
                pc.addEventListener('icegatheringstatechange', check);
                // Wait for TURN relay candidates on slow mobile networks (TURN can take 10-15s)
                setTimeout(() => {
                    console.log('[ICE] Gathering timeout reached, state:', pc.iceGatheringState);
                    resolve();
                }, 15000);
            });
        }

        // ============== Event Listeners ==============
        function setupEventListeners() {
            newTabBtn.addEventListener('click', showNewSessionDialog);

            mobileSelect.addEventListener('change', (e) => {
                manager.setActive(e.target.value);
            });

            reconnectBtn.addEventListener('click', () => {
                const session = manager.getActiveSession();
                if (session && session.code) {
                    session.status = 'new';
                    session.pc = null;
                    session.dc = null;
                    showConnectScreen(session, 'password');
                    manager.updateUI();
                }
            });

            fullscreenBtn.addEventListener('click', () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Don't capture if in input (except terminal)
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.ctrlKey || e.metaKey) {
                    // Ctrl+T: New tab
                    if (e.key === 't') {
                        e.preventDefault();
                        showNewSessionDialog();
                    }
                    // Ctrl+W: Close tab
                    else if (e.key === 'w') {
                        e.preventDefault();
                        const session = manager.getActiveSession();
                        if (session && (manager.sessions.size > 1 || session.status !== 'connected')) {
                            manager.removeSession(session.id);
                            if (manager.sessions.size === 0) showNewSessionDialog();
                        }
                    }
                    // Ctrl+1-9: Switch tabs
                    else if (e.key >= '1' && e.key <= '9') {
                        e.preventDefault();
                        const idx = parseInt(e.key) - 1;
                        const ids = Array.from(manager.sessions.keys());
                        if (ids[idx]) manager.setActive(ids[idx]);
                    }
                    // Ctrl+Shift+R: Reconnect
                    else if (e.key === 'R' && e.shiftKey) {
                        e.preventDefault();
                        reconnectBtn.click();
                    }
                }
            });

            // Show shortcuts hint on ?
            document.addEventListener('keydown', (e) => {
                if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
                    const hint = document.getElementById('shortcuts-hint');
                    hint.classList.toggle('show');
                    setTimeout(() => hint.classList.remove('show'), 3000);
                }
            });
        }

        // ============== Mobile Keyboard Handling ==============
        function setupMobileViewport() {
            const app = document.getElementById('app');
            const html = document.documentElement;
            const body = document.body;
            let resizeTimeout = null;
            let lastHeight = window.innerHeight;
            let keyboardVisible = false;
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

            function setAppHeight(height) {
                const h = Math.floor(height) + 'px';
                app.style.height = h;
                app.style.maxHeight = h;
                html.style.height = h;
                body.style.height = h;
            }

            function updateHeight() {
                // Use visualViewport if available, fallback to innerHeight
                let vh;
                if (window.visualViewport) {
                    vh = window.visualViewport.height;
                } else {
                    vh = window.innerHeight;
                }

                // Apply height
                setAppHeight(vh);
                lastHeight = vh;

                // Debounce terminal refit
                if (resizeTimeout) clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    const session = manager.getActiveSession();
                    if (session && session.fitAddon) {
                        session.fitAddon.fit();
                    }
                }, 50);
            }

            // Check if element is a text input (including xterm's hidden textarea)
            function isTextInput(el) {
                if (!el) return false;
                if (el.tagName === 'INPUT' && el.type !== 'button' && el.type !== 'submit') return true;
                if (el.tagName === 'TEXTAREA') return true;
                // xterm.js uses a helper textarea with this class
                if (el.classList && el.classList.contains('xterm-helper-textarea')) return true;
                return false;
            }

            // Continuous polling for viewport changes (always on mobile)
            let pollInterval = null;
            function startPolling() {
                if (pollInterval) return;
                pollInterval = setInterval(() => {
                    const currentHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                    if (Math.abs(currentHeight - lastHeight) > 5) {
                        updateHeight();
                    }
                }, 100);
            }
            function stopPolling() {
                if (pollInterval) {
                    clearInterval(pollInterval);
                    pollInterval = null;
                }
            }

            // Listen to visualViewport events
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', updateHeight);
                window.visualViewport.addEventListener('scroll', updateHeight);
            }
            window.addEventListener('resize', updateHeight);

            // Detect keyboard via focus
            document.addEventListener('focusin', (e) => {
                if (isTextInput(e.target)) {
                    keyboardVisible = true;
                    startPolling();
                    // Multiple updates to catch keyboard animation
                    setTimeout(updateHeight, 100);
                    setTimeout(updateHeight, 300);
                    setTimeout(updateHeight, 500);
                }
            });

            document.addEventListener('focusout', (e) => {
                if (isTextInput(e.target)) {
                    keyboardVisible = false;
                    setTimeout(() => {
                        if (!keyboardVisible) {
                            updateHeight();
                            // Keep polling on mobile - keyboard can reappear
                            if (!isMobile) stopPolling();
                        }
                    }, 300);
                }
            });

            // Handle orientation change
            window.addEventListener('orientationchange', () => {
                setTimeout(updateHeight, 100);
                setTimeout(updateHeight, 300);
                setTimeout(updateHeight, 500);
            });

            // Expose global function for manual refresh (called after reconnection)
            window.refreshMobileViewport = () => {
                updateHeight();
                setTimeout(updateHeight, 100);
                setTimeout(updateHeight, 300);
            };

            // Always poll on mobile (low overhead, catches all keyboard changes)
            if (isMobile) {
                startPolling();
            }

            // Initial call
            updateHeight();
        }

        // ============== Visibility & Page Lifecycle ==============
        // Handle page visibility changes (tab switch, minimize, etc.)
        let wasHiddenAt = null;

        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                wasHiddenAt = Date.now();
                console.log('[Visibility] Page hidden at', new Date().toLocaleTimeString());
            } else if (document.visibilityState === 'visible') {
                const hiddenDuration = wasHiddenAt ? Date.now() - wasHiddenAt : 0;
                console.log('[Visibility] Page visible after', hiddenDuration, 'ms hidden');
                wasHiddenAt = null;

                // Check all sessions for health
                manager.sessions.forEach((session) => {
                    if (session.status === 'connected') {
                        // Immediately check connection health
                        if (!session.dc || session.dc.readyState !== 'open') {
                            console.log('[Visibility] DC not open on restore, triggering reconnect');
                            handleDisconnect(session, true);
                        } else {
                            // Send immediate ping to verify connection is alive
                            console.log('[Visibility] Sending health check ping');
                            session.lastPingTime = Date.now();
                            sendMessage(session, MSG_PING, new Uint8Array(0));

                            // If we were hidden for a while, check pong timeout more aggressively
                            if (hiddenDuration > 5000) {
                                setTimeout(() => {
                                    if (session.status === 'connected' &&
                                        session.lastPongTime < session.lastPingTime) {
                                        console.log('[Visibility] No pong after visibility restore, reconnecting');
                                        handleDisconnect(session, true);
                                    }
                                }, 3000); // Wait 3s for pong response
                            }
                        }
                    } else if (session.status === 'disconnected' && session.code && session.password) {
                        // Was disconnected while hidden - try immediate reconnect
                        console.log('[Visibility] Was disconnected while hidden, attempting immediate reconnect');
                        session.visibilityReconnect = true; // Flag for instant reconnect
                        attemptAutoReconnect(session);
                    }
                });

                // Refresh mobile viewport in case keyboard state changed
                if (window.refreshMobileViewport) window.refreshMobileViewport();
            }
        });

        // Page Lifecycle API - handle freeze/resume (more aggressive than visibility)
        if ('onfreeze' in document) {
            document.addEventListener('freeze', () => {
                console.log('[Lifecycle] Page frozen');
                manager.sessions.forEach((session) => {
                    session.wasFrozen = true;
                });
            });

            document.addEventListener('resume', () => {
                console.log('[Lifecycle] Page resumed from freeze');
                manager.sessions.forEach((session) => {
                    if (session.wasFrozen) {
                        session.wasFrozen = false;
                        // Force reconnect after freeze - connection is likely dead
                        if (session.status === 'connected') {
                            console.log('[Lifecycle] Forcing reconnect after freeze');
                            handleDisconnect(session, true);
                        }
                    }
                });
            });
        }

        // ============== Start ==============
        init();
        setupMobileViewport();

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('SW registered:', reg.scope))
                .catch(err => console.log('SW registration failed:', err));
        }
    })();
    </script>
</body>
</html>
