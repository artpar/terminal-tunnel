<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Terminal Tunnel</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            background: #1a1a2e;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        #app { height: 100%; display: flex; flex-direction: column; }

        /* Connection screen */
        #connect-screen {
            flex: 1; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            padding: 20px;
        }
        .logo { font-size: 48px; margin-bottom: 10px; }
        h1 { color: #e94560; margin-bottom: 20px; font-size: 24px; }
        .status { color: #888; margin-bottom: 20px; font-size: 14px; }
        .error { color: #ff6b6b; }
        .success { color: #4ecdc4; }

        .form-container {
            background: #16213e; padding: 30px; border-radius: 12px;
            width: 100%; max-width: 500px;
        }
        .form-container label { color: #888; display: block; margin-bottom: 8px; }
        .form-container input, .form-container textarea {
            width: 100%; padding: 12px; border: none; border-radius: 8px;
            background: #0f3460; color: #fff; font-size: 14px;
            margin-bottom: 15px; font-family: monospace;
        }
        .form-container textarea { height: 120px; resize: vertical; }
        .form-container input:focus, .form-container textarea:focus { outline: 2px solid #e94560; }
        .form-container button {
            width: 100%; padding: 14px; border: none; border-radius: 8px;
            background: #e94560; color: #fff; font-size: 16px;
            cursor: pointer; font-weight: 600; margin-top: 10px;
        }
        .form-container button:disabled { background: #444; cursor: not-allowed; }
        .form-container button:hover:not(:disabled) { background: #ff6b6b; }
        .form-container button.secondary {
            background: #0f3460; margin-top: 10px;
        }
        .form-container button.secondary:hover { background: #1a4a8a; }

        /* Mode tabs */
        .mode-tabs {
            display: flex; margin-bottom: 20px;
        }
        .mode-tab {
            flex: 1; padding: 10px; text-align: center;
            background: #0f3460; color: #888; cursor: pointer;
            border: none; font-size: 14px;
        }
        .mode-tab:first-child { border-radius: 8px 0 0 8px; }
        .mode-tab:last-child { border-radius: 0 8px 8px 0; }
        .mode-tab.active { background: #e94560; color: #fff; }

        /* Answer display */
        .answer-display {
            background: #0f3460; padding: 15px; border-radius: 8px;
            margin-top: 15px;
        }
        .answer-display label { color: #4ecdc4; margin-bottom: 10px; }
        .answer-display textarea {
            margin-bottom: 10px; background: #16213e;
        }

        /* Terminal screen */
        #terminal-screen { display: none; flex: 1; flex-direction: column; }
        #terminal-container { flex: 1; padding: 4px; }
        #terminal-container .xterm { height: 100%; }

        .toolbar {
            background: #16213e; padding: 8px 12px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .toolbar-left { color: #4ecdc4; font-size: 14px; }
        .toolbar-right button {
            background: #0f3460; border: none; color: #888;
            padding: 6px 12px; border-radius: 4px; cursor: pointer;
            margin-left: 8px;
        }
        .toolbar-right button:hover { background: #e94560; color: #fff; }

        /* Loading spinner */
        .spinner {
            border: 3px solid #16213e; border-top: 3px solid #e94560;
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="app">
        <!-- Connection Screen -->
        <div id="connect-screen">
            <div class="logo">üîó</div>
            <h1>Terminal Tunnel</h1>
            <div id="status" class="status">Initializing...</div>

            <!-- Auto/HTTP mode form -->
            <div id="auto-form" class="form-container hidden">
                <label for="password">Enter Password</label>
                <input type="password" id="password" placeholder="Session password" autocomplete="off">
                <button id="connect-btn">Connect</button>
            </div>

            <!-- Manual mode form -->
            <div id="manual-form" class="form-container hidden">
                <div class="mode-tabs">
                    <button class="mode-tab active" id="tab-auto">Auto</button>
                    <button class="mode-tab" id="tab-manual">Manual</button>
                </div>

                <div id="manual-input-section" class="hidden">
                    <label for="offer-input">Paste Connection Code</label>
                    <textarea id="offer-input" placeholder="Paste the connection code from the host terminal..."></textarea>
                    <label for="manual-password">Password</label>
                    <input type="password" id="manual-password" placeholder="Session password" autocomplete="off">
                    <button id="manual-connect-btn">Connect</button>
                </div>

                <div id="manual-answer-section" class="hidden">
                    <div class="answer-display">
                        <label>Share this answer code with the host:</label>
                        <textarea id="answer-output" readonly></textarea>
                        <button id="copy-answer-btn" class="secondary">Copy to Clipboard</button>
                    </div>
                    <p style="color: #888; text-align: center; margin-top: 15px; font-size: 12px;">
                        Waiting for host to complete connection...
                    </p>
                </div>
            </div>

            <div id="loading" class="spinner"></div>
        </div>

        <!-- Terminal Screen -->
        <div id="terminal-screen">
            <div class="toolbar">
                <div class="toolbar-left">
                    <span id="connection-status">‚óè Connected</span>
                </div>
                <div class="toolbar-right">
                    <button id="fullscreen-btn">‚õ∂</button>
                    <button id="disconnect-btn">‚úï</button>
                </div>
            </div>
            <div id="terminal-container"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/argon2-browser@1.18.0/dist/argon2-bundled.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <script>
    (function() {
        'use strict';

        // State
        let pc = null;
        let dc = null;
        let term = null;
        let fitAddon = null;
        let encryptionKey = null;
        let salt = null;
        let connectionMode = 'auto'; // auto, relay, manual

        // DOM elements
        const connectScreen = document.getElementById('connect-screen');
        const terminalScreen = document.getElementById('terminal-screen');
        const statusEl = document.getElementById('status');
        const loadingEl = document.getElementById('loading');
        const autoForm = document.getElementById('auto-form');
        const manualForm = document.getElementById('manual-form');
        const passwordInput = document.getElementById('password');
        const connectBtn = document.getElementById('connect-btn');
        const terminalContainer = document.getElementById('terminal-container');
        const connectionStatus = document.getElementById('connection-status');

        // Manual mode elements
        const tabAuto = document.getElementById('tab-auto');
        const tabManual = document.getElementById('tab-manual');
        const manualInputSection = document.getElementById('manual-input-section');
        const manualAnswerSection = document.getElementById('manual-answer-section');
        const offerInput = document.getElementById('offer-input');
        const manualPasswordInput = document.getElementById('manual-password');
        const manualConnectBtn = document.getElementById('manual-connect-btn');
        const answerOutput = document.getElementById('answer-output');
        const copyAnswerBtn = document.getElementById('copy-answer-btn');

        // Message types (must match Go protocol)
        const MSG_DATA = 0x01;
        const MSG_RESIZE = 0x02;
        const MSG_PING = 0x03;
        const MSG_PONG = 0x04;
        const MSG_CLOSE = 0x05;

        // Compact format version
        const COMPACT_VERSION = 0x01;
        const SALT_SIZE = 16;

        // Initialize
        async function init() {
            // Check URL params for connection mode
            const params = new URLSearchParams(window.location.search);
            const relayUrl = params.get('relay');
            const session = params.get('session');
            const manualMode = params.get('manual');

            if (manualMode === 'true' || manualMode === '1') {
                // Manual mode - show input form
                connectionMode = 'manual';
                loadingEl.classList.add('hidden');
                manualForm.classList.remove('hidden');
                manualInputSection.classList.remove('hidden');
                setStatus('Paste the connection code from the host', 'info');
                return;
            }

            if (relayUrl && session) {
                // Relay mode
                connectionMode = 'relay';
                await initRelay(relayUrl, session);
                return;
            }

            // Default: HTTP/auto mode
            try {
                setStatus('Fetching session...', 'info');
                const response = await fetch('/offer');
                const data = await response.json();

                salt = base64ToBytes(data.salt || '');
                window.sessionOffer = data.offer;
                window.sessionId = data.sessionId;

                setStatus('Enter password to connect', 'info');
                loadingEl.classList.add('hidden');
                autoForm.classList.remove('hidden');
                passwordInput.focus();

            } catch (err) {
                // Offer endpoint failed - show manual mode option
                setStatus('Direct connection unavailable. Use manual mode.', 'info');
                loadingEl.classList.add('hidden');
                manualForm.classList.remove('hidden');
                manualInputSection.classList.remove('hidden');
                connectionMode = 'manual';
            }
        }

        // Initialize relay mode
        async function initRelay(relayUrl, sessionId) {
            setStatus('Connecting to relay...', 'info');

            try {
                const ws = new WebSocket(relayUrl + '?session=' + sessionId);

                ws.onopen = () => {
                    ws.send(JSON.stringify({
                        type: 'register',
                        session_id: sessionId,
                        role: 'client'
                    }));
                };

                ws.onmessage = async (event) => {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'offer') {
                        salt = base64ToBytes(msg.salt || '');
                        window.sessionOffer = msg.sdp;
                        window.sessionId = sessionId;
                        window.relayWs = ws;

                        setStatus('Enter password to connect', 'info');
                        loadingEl.classList.add('hidden');
                        autoForm.classList.remove('hidden');
                        passwordInput.focus();
                    } else if (msg.type === 'error') {
                        setStatus('Relay error: ' + msg.error, 'error');
                    }
                };

                ws.onerror = () => {
                    setStatus('Relay connection failed', 'error');
                    loadingEl.classList.add('hidden');
                };

            } catch (err) {
                setStatus('Failed to connect to relay: ' + err.message, 'error');
                loadingEl.classList.add('hidden');
            }
        }

        // Connect with password (auto/relay mode)
        async function connect() {
            const password = passwordInput.value;
            if (!password) {
                setStatus('Please enter a password', 'error');
                return;
            }

            connectBtn.disabled = true;
            await doConnect(password, window.sessionOffer, salt);
        }

        // Connect in manual mode
        async function manualConnect() {
            const compactOffer = offerInput.value.trim();
            const password = manualPasswordInput.value;

            if (!compactOffer) {
                setStatus('Please paste the connection code', 'error');
                return;
            }
            if (!password) {
                setStatus('Please enter a password', 'error');
                return;
            }

            manualConnectBtn.disabled = true;
            setStatus('Decoding offer...', 'info');

            try {
                // Decode compact offer
                const { sdp, decodedSalt } = decodeCompactOffer(compactOffer);
                salt = decodedSalt;
                window.sessionOffer = sdp;

                await doConnect(password, sdp, salt, true);

            } catch (err) {
                setStatus('Failed to decode: ' + err.message, 'error');
                manualConnectBtn.disabled = false;
            }
        }

        // Common connection logic
        async function doConnect(password, offer, saltBytes, isManual = false) {
            try {
                setStatus('Deriving encryption key...', 'info');
                encryptionKey = await deriveKey(password, saltBytes);

                setStatus('Establishing connection...', 'info');

                pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                pc.ondatachannel = (event) => {
                    dc = event.channel;
                    setupDataChannel();
                };

                await pc.setRemoteDescription({ type: 'offer', sdp: offer });
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await waitForICE();

                if (isManual) {
                    // Show answer for user to copy
                    const compactAnswer = encodeCompactAnswer(pc.localDescription.sdp);
                    manualInputSection.classList.add('hidden');
                    manualAnswerSection.classList.remove('hidden');
                    answerOutput.value = compactAnswer;
                    setStatus('Copy the answer code and share with host', 'success');
                } else if (connectionMode === 'relay' && window.relayWs) {
                    // Send answer via relay
                    window.relayWs.send(JSON.stringify({
                        type: 'answer',
                        session_id: window.sessionId,
                        sdp: pc.localDescription.sdp
                    }));
                    setStatus('Waiting for connection...', 'success');
                } else {
                    // Send answer via HTTP
                    setStatus('Sending answer...', 'info');
                    const resp = await fetch('/answer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ answer: pc.localDescription.sdp })
                    });
                    if (!resp.ok) throw new Error('Failed to send answer');
                    setStatus('Waiting for connection...', 'success');
                }

            } catch (err) {
                setStatus('Connection failed: ' + err.message, 'error');
                connectBtn.disabled = false;
                manualConnectBtn.disabled = false;
            }
        }

        // Decode compact offer (matches Go implementation)
        function decodeCompactOffer(encoded) {
            // Base64 decode
            let data;
            try {
                // Try URL-safe base64 first
                const base64 = encoded.replace(/-/g, '+').replace(/_/g, '/');
                const padded = base64 + '='.repeat((4 - base64.length % 4) % 4);
                data = Uint8Array.from(atob(padded), c => c.charCodeAt(0));
            } catch (e) {
                throw new Error('Invalid base64 encoding');
            }

            if (data.length < 1 + SALT_SIZE + 1) {
                throw new Error('Data too short');
            }

            const version = data[0];
            if (version !== COMPACT_VERSION) {
                throw new Error('Unsupported version: ' + version);
            }

            const decodedSalt = data.slice(1, 1 + SALT_SIZE);
            const compressed = data.slice(1 + SALT_SIZE);

            // Decompress with pako (raw deflate, no zlib header)
            let sdpBytes;
            try {
                sdpBytes = pako.inflateRaw(compressed);
            } catch (e) {
                throw new Error('Decompression failed: ' + e.message);
            }

            return {
                sdp: new TextDecoder().decode(sdpBytes),
                decodedSalt: decodedSalt
            };
        }

        // Encode compact answer
        function encodeCompactAnswer(sdp) {
            const sdpBytes = new TextEncoder().encode(sdp);
            const compressed = pako.deflateRaw(sdpBytes);

            const data = new Uint8Array(1 + compressed.length);
            data[0] = COMPACT_VERSION;
            data.set(compressed, 1);

            // URL-safe base64
            const base64 = btoa(String.fromCharCode.apply(null, data));
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        // Setup data channel handlers
        function setupDataChannel() {
            dc.binaryType = 'arraybuffer';

            dc.onopen = () => {
                console.log('Data channel open');
                showTerminal();
            };

            dc.onclose = () => {
                console.log('Data channel closed');
                connectionStatus.textContent = '‚óè Disconnected';
                connectionStatus.style.color = '#ff6b6b';
            };

            dc.onmessage = async (event) => {
                try {
                    const decrypted = await decrypt(new Uint8Array(event.data));
                    const msg = parseMessage(decrypted);

                    if (msg.type === MSG_DATA) {
                        term.write(new Uint8Array(msg.payload));
                    } else if (msg.type === MSG_PING) {
                        sendMessage(MSG_PONG, new Uint8Array(0));
                    } else if (msg.type === MSG_CLOSE) {
                        dc.close();
                    }
                } catch (err) {
                    console.error('Decrypt error:', err);
                }
            };
        }

        // Show terminal
        function showTerminal() {
            connectScreen.style.display = 'none';
            terminalScreen.style.display = 'flex';

            term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#1a1a2e',
                    foreground: '#e0e0e0',
                    cursor: '#e94560',
                    cursorAccent: '#1a1a2e'
                }
            });

            fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(terminalContainer);
            fitAddon.fit();

            term.onData((data) => {
                sendMessage(MSG_DATA, new TextEncoder().encode(data));
            });

            const resizeObserver = new ResizeObserver(() => {
                fitAddon.fit();
                sendResize();
            });
            resizeObserver.observe(terminalContainer);

            setTimeout(sendResize, 100);
            term.focus();
        }

        function sendResize() {
            const dims = fitAddon.proposeDimensions();
            if (!dims) return;

            const payload = new Uint8Array(4);
            payload[0] = (dims.rows >> 8) & 0xFF;
            payload[1] = dims.rows & 0xFF;
            payload[2] = (dims.cols >> 8) & 0xFF;
            payload[3] = dims.cols & 0xFF;

            sendMessage(MSG_RESIZE, payload);
        }

        async function sendMessage(type, payload) {
            if (!dc || dc.readyState !== 'open') return;

            const msg = new Uint8Array(3 + payload.length);
            msg[0] = type;
            msg[1] = (payload.length >> 8) & 0xFF;
            msg[2] = payload.length & 0xFF;
            msg.set(payload, 3);

            const encrypted = await encrypt(msg);
            dc.send(encrypted);
        }

        function parseMessage(data) {
            return {
                type: data[0],
                length: (data[1] << 8) | data[2],
                payload: data.slice(3)
            };
        }

        async function deriveKey(password, salt) {
            const result = await argon2.hash({
                pass: password,
                salt: salt || new Uint8Array(16),
                time: 3,
                mem: 65536,
                parallelism: 4,
                hashLen: 32,
                type: argon2.ArgonType.Argon2id
            });
            return result.hash;
        }

        async function encrypt(plaintext) {
            const nonce = nacl.randomBytes(24);
            const encrypted = nacl.secretbox(plaintext, nonce, encryptionKey);
            const result = new Uint8Array(24 + encrypted.length);
            result.set(nonce);
            result.set(encrypted, 24);
            return result;
        }

        async function decrypt(ciphertext) {
            const nonce = ciphertext.slice(0, 24);
            const encrypted = ciphertext.slice(24);
            const decrypted = nacl.secretbox.open(encrypted, nonce, encryptionKey);
            if (!decrypted) throw new Error('Decryption failed');
            return decrypted;
        }

        function waitForICE() {
            return new Promise((resolve) => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                    return;
                }
                pc.onicegatheringstatechange = () => {
                    if (pc.iceGatheringState === 'complete') resolve();
                };
                setTimeout(resolve, 10000);
            });
        }

        function setStatus(msg, type) {
            statusEl.textContent = msg;
            statusEl.className = 'status ' + (type || '');
        }

        function base64ToBytes(base64) {
            if (!base64) return new Uint8Array(16);
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        // Event handlers
        connectBtn.onclick = connect;
        passwordInput.onkeypress = (e) => { if (e.key === 'Enter') connect(); };

        manualConnectBtn.onclick = manualConnect;
        manualPasswordInput.onkeypress = (e) => { if (e.key === 'Enter') manualConnect(); };

        copyAnswerBtn.onclick = () => {
            answerOutput.select();
            document.execCommand('copy');
            copyAnswerBtn.textContent = 'Copied!';
            setTimeout(() => { copyAnswerBtn.textContent = 'Copy to Clipboard'; }, 2000);
        };

        // Mode tabs (when in fallback mode)
        if (tabAuto && tabManual) {
            tabAuto.onclick = () => {
                tabAuto.classList.add('active');
                tabManual.classList.remove('active');
                manualInputSection.classList.add('hidden');
                // Try auto mode again
                init();
            };
            tabManual.onclick = () => {
                tabManual.classList.add('active');
                tabAuto.classList.remove('active');
                manualInputSection.classList.remove('hidden');
                setStatus('Paste the connection code from the host', 'info');
            };
        }

        document.getElementById('fullscreen-btn').onclick = () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        };

        document.getElementById('disconnect-btn').onclick = () => {
            if (dc) dc.close();
            if (pc) pc.close();
            window.location.reload();
        };

        // Start
        init();
    })();
    </script>
</body>
</html>
